<!DOCTYPE html>
<!-- saved from url=(0055)https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/07/answers -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<title>
    
    COMP1511 20T3 - 
Week 07
Laboratory
Sample Solutions

    
</title><link rel="canonical" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/">

<link rel="stylesheet" href="./COMP1511 20T3 - Week 07 Laboratory Sample Solutions_files/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
<link rel="stylesheet" href="./COMP1511 20T3 - Week 07 Laboratory Sample Solutions_files/course.css">

<script src="./COMP1511 20T3 - Week 07 Laboratory Sample Solutions_files/jquery.min.js.download" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="./COMP1511 20T3 - Week 07 Laboratory Sample Solutions_files/popper.min.js.download" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="./COMP1511 20T3 - Week 07 Laboratory Sample Solutions_files/bootstrap.min.js.download" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
<script src="./COMP1511 20T3 - Week 07 Laboratory Sample Solutions_files/course.js.download"></script>


<link rel="icon" type="image/png" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/flask.cgi/static/favicon.ico?1271605745352.0">

<!-- <script async src="https://static.codepen.io/assets/embed/ei.js"></script> -->

<!-- MathJax. -->






<style>
body {
    background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' height='50px' width='220px'><text x='0' y='15' fill='red' font-size='20' opacity='0.2'>  [OLD - 20T3]  </text></svg>");
}
</style>

<script type="text/javascript" async="" src="./COMP1511 20T3 - Week 07 Laboratory Sample Solutions_files/MathJax.js.download"></script><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover, .MJXp-munder {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > *, .MJXp-munder > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body class="d-flex flex-column vsc-initialized" style="min-height: 100vh;"><div id="MathJax_Message" style="display: none;"></div>
  <nav class="navbar fixed-top navbar-expand-lg navbar-light no-print" id="header-navbar">
  <div class="container">
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navmenu" aria-controls="navmenu" aria-label="Toggle navigation" aria-expanded="false">
      <span class="navbar-toggler-icon"></span>
    </button>

    <a class="navbar-brand" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/">
      COMP1511 20T3
    </a>

    <div class="collapse navbar-collapse" id="navmenu">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item active"><a class="nav-link" href="https://discourse.cse.unsw.edu.au/20t3/comp1511/">Forum</a></li>
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">Submissions</a></li>
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/history/">History</a></li>

        
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/assignments/ass1/index.html">Assignment 1</a></li>
        

        
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/assignments/ass2/index.html">Assignment 2</a></li>
        

        <li class="navbar-text px-2">|</li>
        


    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
            
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    


<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="week-selector" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/07/answers#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Week 07 <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="week-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/01/answers">Week 01</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/02/answers">Week 02</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/03/answers">Week 03</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/04/answers">Week 04</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/05/answers">Week 05</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/06/answers">Week 06 (tutors only)</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/07/answers">Week 07</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/08/answers">Week 08</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/09/answers">Week 09</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/10/answers">Week 10</a>
  </div>
</li>



    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    


<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="tlb-selector" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/07/answers#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Laboratory <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="tlb-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/tut/07/answers">Tutorial</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/07/answers">Laboratory</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/test/07/answers">Weekly Test</a>
  </div>
</li>



    
    
    
    

    
    
    
    



<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="qa-selector" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/07/answers#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Sample Solutions <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="qa-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/07/questions">Exercises</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/07/answers">Sample Solutions</a>
  </div>
</li>


      </ul>
    </div>
  </div>
</nav>


<main class="container" aria-label="Content" style="flex: 1; padding-top: 4rem;">


<header>

<h1 class="text-center">
Week 07
Laboratory
Sample Solutions
</h1>

</header>


<div class="tutlab lab">




<section class="exercise ">
    <header><h3>Objectives</h3></header>
    

<ul>

<li>processing of characters and strings</li>

<li>use of functions</li>

<li>an introduction to encryption &amp; decryption</li>

</ul>


    </section>



<section class="exercise ">
    <header><h3>Preparation</h3></header>
    


<p>
Before the lab you should re-read the relevant lecture slides and their accompanying examples.



    </p></section>









 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br>Devowelling Text</h3></header>
    










Write a C program <code>devowel.c</code> which reads characters from its input
and writes the same characters to its output, except it does not write lower case vowels ('a', 'e', 'i', 'o', 'u').
<p>
Your program should stop only at the end of input.
</p><p>
For example:

</p><pre is="tty"><kbd is="sh">./devowel</kbd>
<kbd>Are you saying 'Boo' or 'Boo-Urns'?</kbd>
Ar y syng 'B' r 'B-Urns'?
<kbd>In this house, we obey the laws of thermodynamics!</kbd>
In ths hs, w by th lws f thrmdynmcs!
<span class="eof"></span>
</pre>

<b>Hint</b>: hint use <code>getchar</code> to read characters (don't use <code>scanf</code> or <code>fgets</code>).
<p>
<b>Hint</b>: you need only a single int variable.  Don't use an array.
</p><p>
<b>Hint</b>: use <code>putchar</code> to output each character.
</p><p>
<b>Hint</b>: make sure you understand this <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/code/characters_and_strings/getchar_eof.c">example program</a> which reads characters until end of input.
</p><p>
<b>Hint</b>: make sure you understand this  <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/code/characters_and_strings/upper_case.c">example program</a> which reads characters, printing them with lower case letters converted to upper case.
</p><p>
<b>Hint</b>: create a function with a prototype like this:

</p><pre class="program">int is_vowel(int character);
</pre>

which returns 1 the character is a lower case vowel and 0 otherwise.
<p>
<b>Hint</b>: To tell the program you have finished typing,
you can press <kbd>Ctrl+D</kbd>.









</p><div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style devowel.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest devowel</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab07_devowel devowel.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 01 November 2020 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            </p><div class="answer">
                Sample solution for <code>devowel.c</code>
                
<div class="highlight"><pre><span></span><span class="c1">//  Written 3/3/2018 by Andrew Taylor (andrewt@unsw.edu.au)</span>
<span class="c1">//  read characters from stdin and write to stdout</span>
<span class="c1">//  except lower case vowels ('a', 'e','i', 'o', 'u') are not written</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">is_vowel</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// getchar returns an int which will contain either</span>
    <span class="c1">// the ASCII code of the character read or EOF</span>

    <span class="kt">int</span> <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">character</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_vowel</span><span class="p">(</span><span class="n">character</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">putchar</span><span class="p">(</span><span class="n">character</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// return 1 if character is a lower case vowel</span>
<span class="c1">// 0 otherwise</span>

<span class="kt">int</span> <span class="nf">is_vowel</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">character</span> <span class="o">==</span> <span class="sc">'a'</span> <span class="o">||</span>
           <span class="n">character</span> <span class="o">==</span> <span class="sc">'e'</span> <span class="o">||</span>
           <span class="n">character</span> <span class="o">==</span> <span class="sc">'i'</span> <span class="o">||</span>
           <span class="n">character</span> <span class="o">==</span> <span class="sc">'o'</span> <span class="o">||</span>
           <span class="n">character</span> <span class="o">==</span> <span class="sc">'u'</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br>Its a Case of Swapping</h3></header>
    









<div class="alert alert-info">
    

<p>
Download swap_case.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/swap_case/swap_case.c">here</a>, or copy it to your CSE
account using the following command:

</p><pre is="tty"><kbd is="sh">cp -n /web/cs1511/20T3/activities/swap_case/swap_case.c .</kbd>
</pre>


</div>
<p>
Edit the C program <code>swap_case.c</code> (linked above) which reads characters from its input
and writes the same characters to its output with lower case letters converted to upper case
and upper case letters converted to lower case. 
</p><p>
    Your program should stop only at the end of input.
</p><p>
    To help you format your code nicely, your program must use a function with signature:

</p><pre class="program">int swap_case(int character);
</pre>

which:
<ul>
<li> returns the character in lower case if it is an upper case letter
</li><li> returns the character in upper case if it is a lower case letter
</li><li> returns the character unchanged otherwise
</li></ul>
<p>
<b>Note:</b> Your program will not pass autotests if it does not contain this function.
</p><p>
For example:

</p><pre is="tty"><kbd is="sh">dcc swap_case.c -o swap_case</kbd>
<kbd is="sh">./swap_case</kbd>
<kbd>Are you saying 'Boo' or 'Boo-Urns'?</kbd>
aRE YOU SAYING 'bOO' OR 'bOO-uRNS'?
<kbd>In this house, we obey the laws of thermodynamics!</kbd>
iN THIS HOUSE, WE OBEY THE LAWS OF THERMODYNAMICS!
<kbd>UPPER !@#$% lower</kbd>
upper !@#$% LOWER
<span class="eof"></span>
</pre>

<b>Hint</b>: hint use <code>getchar</code> to read characters (don't use <code>scanf</code> or <code>fgets</code>).
<p>
<b>Hint</b>: you need only a single int variable.  Don't use an array.
</p><p>
<b>Hint</b>: use <code>putchar</code> to output each character.
</p><p>
<b>Hint</b>: make sure you understand this <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/code/characters_and_strings/getchar_eof.c">example program</a> which reads characters until end of input.
</p><p>
<b>Hint</b>: make sure you understand this  <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/code/characters_and_strings/upper_case.c">example program</a> which reads characters, printing them with lower case letters converted to upper case.
</p><p>









</p><div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style swap_case.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest swap_case</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab07_swap_case swap_case.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 01 November 2020 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            </p><div class="answer">
                Sample solution for <code>swap_case.c</code>
                
<div class="highlight"><pre><span></span><span class="c1">//  Written 3/3/2018 by Andrew Taylor (andrewt@unsw.edu.au)</span>
<span class="c1">//  Write stdin to stdout with upper case letters converted to lower case</span>
<span class="c1">// and lower case converted to upper case</span>
<span class="c1">//</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">swap_case</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">character</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">swapped_character</span> <span class="o">=</span> <span class="n">swap_case</span><span class="p">(</span><span class="n">character</span><span class="p">);</span>
        <span class="n">putchar</span><span class="p">(</span><span class="n">swapped_character</span><span class="p">);</span>
        <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">swap_case</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="n">character</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="sc">'A'</span> <span class="o">+</span> <span class="n">character</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">character</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br>Its a (Test) Case of Swapping</h3></header>
    









<div class="alert alert-info">
    

<p>
Download swap_case_test.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/swap_case_test/swap_case_test.c">here</a>, or copy it to your CSE
account using the following command:

</p><pre is="tty"><kbd is="sh">cp -n /web/cs1511/20T3/activities/swap_case_test/swap_case_test.c .</kbd>
</pre>


</div>
<h4>Read Me First: Software Testing</h4>

<p>
    One of the most fundamental parts of writing software is testing. In this course,
    we mostly do the testing for you -- the <code>autotest</code> program checks
    your software is correct. While this is handy, testing will not always be so easy. In the following
    labs, and in Assignment 2, there will be a focus on writing tests yourself.
</p><p>
    For this program, you will be asked to write a program that tests some code --
    the code you will test is your <code>swap_case</code> function from the previous exercise.
    To test your code, we have written some <b>incorrect</b> solutions. Your job is to tell
    us in whether the solution meets the specification given in the last exercise. That means,
    you will have to tell us whether <code>swap_case</code>:
</p><ul>
<li> returns the character in lower case if it is an upper case letter
</li><li> returns the character in upper case if it is a lower case letter
</li><li> returns the character unchanged otherwise
</li></ul>
<p></p> 
<h4>Swap Case Test</h4>
<p>
    Edit the C program <code>swap_case_test.c</code> (linked above) so that it tests whether
    the <code>swap_case</code> function is correct. You should not edit the main function;
    and you should not use <code>scanf</code>, <code>printf</code>, <code>getchar</code> or any
    other functions from <code>stdio.h</code>. You can hardcode the inputs to <code>swap_case</code>
    inside your testing functions.
</p><p>
    You will only need to edit the <code>test_lower_to_upper</code> function, the <code>test_upper_to_lower</code>
    and the <code>test_non_alphabetical</code> function. Each function should call <code>swap_case</code>, and
    depending on it's output, should return <code>MEETS_SPEC</code> (if <code>swap_case</code> did the right thing,
    or <code>DOES_NOT_MEET_SPEC</code> if it does something unexpected.
</p><p>
    For example, if <code>swap_case</code> was the following function:
</p><div class="code">
<pre class="program">int swap_case(int character) {
    return character;
}
</pre>
</div>
<p> Your program should behave as follows:</p>

<pre is="tty"><kbd is="sh">dcc swap_case_test.c -o swap_case_test</kbd>
<kbd is="sh">./swap_case_test</kbd>
Testing turning an lowercase into uppercase: DOES NOT MEET SPEC
Testing turning an uppercase into lowercase: DOES NOT MEET SPEC
Testing a non-alphabetical character not changing: MEETS SPEC
</pre>

<p>
    For example, if <code>swap_case</code> was the following function:
</p><div class="code">
<pre class="program">int swap_case(int character) {
    return 1000;
}
</pre>
</div>
<p> Your program should behave as follows:</p>

<pre is="tty"><kbd is="sh">dcc swap_case_test.c -o swap_case_test</kbd>
<kbd is="sh">./swap_case_test</kbd>
Testing turning an lowercase into uppercase: DOES NOT MEET SPEC
Testing turning an uppercase into lowercase: DOES NOT MEET SPEC
Testing a non-alphabetical character not changing: DOES NOT MEET SPEC
</pre>

<p>
    For example, if <code>swap_case</code> was the code you wrote in the last exercise,
    Your program should (hopefully) behave as follows:</p>

<pre is="tty"><kbd is="sh">dcc swap_case_test.c -o swap_case_test</kbd>
<kbd is="sh">./swap_case_test</kbd>
Testing turning an lowercase into uppercase: MEETS SPEC
Testing turning an uppercase into lowercase: MEETS SPEC
Testing a non-alphabetical character not changing: MEETS SPEC
</pre>

<p>
<b>NOTE: </b> You don't need to test every valid input -- only testing one or two will be enough.
</p>

<h4>How do we test your code?</h4>

<p>To test your tests, we create a special program that combines our code and yours. You can't create the program directly,
    but if you would like to get access to the program that we use to test your code, run:</p>

<pre is="tty"><kbd is="sh">1511 swap_case_test_compile swap_case_test.c</kbd>
./swap_case_test created!
</pre>
<p>This will create a file <code>swap_case_test</code> which simulates the program we will use to test your tests.</p>









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style swap_case_test.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest swap_case_test</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab07_swap_case_test swap_case_test.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 01 November 2020 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            </p><div class="answer">
                Sample solution for <code>swap_case_test.c</code>
                
<div class="highlight"><pre><span></span><span class="c1">// Function to test your swap_case function.</span>
<span class="c1">// swap_case.c</span>
<span class="c1">//</span>
<span class="c1">// This program was written by YOUR-NAME-HERE (z5555555)</span>
<span class="c1">// on INSERT-DATE-HERE</span>
 
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cp">#define MEETS_SPEC 1</span>
<span class="cp">#define DOES_NOT_MEET_SPEC 0</span>

<span class="kt">int</span> <span class="nf">swap_case</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">test_lower_to_upper</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">test_upper_to_lower</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">test_non_alphabetical</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>


<span class="kt">int</span> <span class="nf">test_lower_to_upper</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">swap_case</span><span class="p">(</span><span class="sc">'a'</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">'A'</span><span class="p">)</span> <span class="k">return</span> <span class="n">DOES_NOT_MEET_SPEC</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">swap_case</span><span class="p">(</span><span class="sc">'c'</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">'C'</span><span class="p">)</span> <span class="k">return</span> <span class="n">DOES_NOT_MEET_SPEC</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">MEETS_SPEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_upper_to_lower</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">swap_case</span><span class="p">(</span><span class="sc">'A'</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">'a'</span><span class="p">)</span> <span class="k">return</span> <span class="n">DOES_NOT_MEET_SPEC</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">swap_case</span><span class="p">(</span><span class="sc">'C'</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">'c'</span><span class="p">)</span> <span class="k">return</span> <span class="n">DOES_NOT_MEET_SPEC</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">MEETS_SPEC</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_non_alphabetical</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">swap_case</span><span class="p">(</span><span class="sc">'!'</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">'!'</span><span class="p">)</span> <span class="k">return</span> <span class="n">DOES_NOT_MEET_SPEC</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">swap_case</span><span class="p">(</span><span class="sc">'9'</span><span class="p">)</span> <span class="o">!=</span> <span class="sc">'9'</span><span class="p">)</span> <span class="k">return</span> <span class="n">DOES_NOT_MEET_SPEC</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">MEETS_SPEC</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">//////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// NOTE: The below function won't be marked! You can use it for testing //</span>
<span class="c1">//////////////////////////////////////////////////////////////////////////</span>

<span class="kt">int</span> <span class="nf">swap_case</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// NOTE: you can test this progarm by copying in your</span>
    <span class="c1">// solution to the previous exercise.</span>
    <span class="k">return</span> <span class="n">character</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// NOTE: DO NOT EDIT BELOW THIS COMMENT!                                //</span>
<span class="c1">//////////////////////////////////////////////////////////////////////////</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Testing turning an lowercase into uppercase: "</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">test_lower_to_upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">MEETS_SPEC</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"MEETS SPEC</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"DOES NOT MEET SPEC</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Testing turning an uppercase into lowercase: "</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">test_upper_to_lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">MEETS_SPEC</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"MEETS SPEC</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"DOES NOT MEET SPEC</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Testing a non-alphabetical character not changing: "</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">test_non_alphabetical</span><span class="p">()</span> <span class="o">==</span> <span class="n">MEETS_SPEC</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"MEETS SPEC</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"DOES NOT MEET SPEC</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br>Encrypting Text with a Caesar Cipher</h3></header>
    










Write a C program <code>caesar.c</code> which reads characters from its input
and writes the  characters to its output encrypted with a <a href="https://en.wikipedia.org/wiki/Caesar_cipher">Caesar cipher</a>.
<p>
A <a href="https://en.wikipedia.org/wiki/Caesar_cipher">Caesar cipher</a> shifts each letter a certain
number of positions in the alphabet.
</p><p>
The number of positions to shift will be given to your program as a command line argument.
</p><p>
Characters other than letters should not be encrypted.
</p><p>
Your program should stop only at the end of input.
</p><p>
Your program should contain at least one function other than main.
</p><p>
For example:

</p><pre is="tty"><kbd is="sh">./caesar 1</kbd>
<kbd>This life well it's slipping right through my hands</kbd>
Uijt mjgf xfmm ju't tmjqqjoh sjhiu uispvhi nz iboet
<kbd>These days turned out nothing like I had planned</kbd>
Uiftf ebzt uvsofe pvu opuijoh mjlf J ibe qmboofe
<span class="eof"></span>
<kbd is="sh">./caesar 10</kbd>
<kbd>abcdefghijklmnopqrstuvwxyz</kbd>
klmnopqrstuvwxyzabcdefghij
<kbd>ABCDEFGHIJKLMNOPQRSTUVWXYZ</kbd>
KLMNOPQRSTUVWXYZABCDEFGHIJ
<span class="eof"></span>
<kbd is="sh">./caesar -42</kbd>
<kbd>Control well it's slipping right through my hands</kbd>
Myxdbyv govv sd'c cvszzsxq bsqrd drbyeqr wi rkxnc
<kbd>These days?</kbd>
Droco nkic?
<span class="eof"></span>
</pre>

<b>Hint</b>: handle upper and lower case letters separately
<p>
<b>Hint</b>: use <code>%</code>
</p><p>
<b>Hint</b>: use <code>atoi</code> to convert the first command-line argument to an int.
</p><p>
<b>Hint</b>:make sure you understand this <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/code/characters_and_strings/sum_arguments.c">example program</a> which uses  a <code>atoi</code> to convert  command-line arguments to an ints.
</p><p>
<b>Hint</b>: create a function with a prototype like this:

</p><pre class="program">int encrypt(int character, int shift);
</pre>

which returns the character shifted by the specified amount

<h4>Manually Cracking a Caesar Cipher</h4>

Here is some (New Zealand) English  text that has been encrypted with a Caesar cipher.
<pre>Z uf dp drbvlg ze jfdvsfup vcjv'j tri
Nv fiuvi uzwwvivek uizebj rk kyv jrdv srij
Z befn rsflk nyrk pfl uzu reu Z nreer jtivrd kyv kilky
Jyv kyzebj pfl cfmv kyv svrty, pfl'iv jlty r urde czri
</pre>

Use the program you have just written to discover  the secret text?
<p>
<b>Hint:</b>: try different shifts until you see English.

</p><div class="answer">
Shift: <b>17</b>

<pre>I do my makeup in somebody else's car
We order different drinks at the same bars
I know about what you did and I wanna scream the truth
She thinks you love the beach, you're such a damn liar
</pre>

</div>
<p>
You program will only be tested with an appropriate command line argument -
but a good programmer would check the command line argument is present and appropriate.










</p><div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style caesar.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest caesar</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab07_caesar caesar.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 01 November 2020 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            </p><div class="answer">
                Sample solution for <code>caesar.c</code>
                
<div class="highlight"><pre><span></span><span class="c1">//  Written 3/3/2018 by Andrew Taylor (andrewt@unsw.edu.au)</span>
<span class="c1">//  Write stdin to stdout encrypted with a Caesar Cipher</span>
<span class="c1">//  https://en.wikipedia.org/wiki/Caesar_cipher</span>
<span class="c1">//</span>
<span class="c1">//  The shift will be supplied as a command-line argument</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>

<span class="cp">#define ALPHABET_SIZE  26</span>

<span class="kt">int</span> <span class="nf">encrypt</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Usage: %s &lt;shift&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">shift</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="c1">// negative shifts need to be converted to the equivalent positive shift</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">shift</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">ALPHABET_SIZE</span> <span class="o">+</span> <span class="p">(</span><span class="n">shift</span> <span class="o">%</span> <span class="n">ALPHABET_SIZE</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">character</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">encrypted_character</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">character</span><span class="p">,</span> <span class="n">shift</span><span class="p">);</span>
        <span class="n">putchar</span><span class="p">(</span><span class="n">encrypted_character</span><span class="p">);</span>
        <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// encrypt letters with a caesar cipher with the specified shift</span>
<span class="c1">// the specified characters is returned shifted the specified number of positions</span>
<span class="c1">// characters other than letters are returned unchanged</span>

<span class="kt">int</span> <span class="nf">encrypt</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">,</span> <span class="kt">int</span> <span class="n">shift</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="sc">'A'</span> <span class="o">+</span> <span class="p">(</span><span class="n">character</span> <span class="o">-</span> <span class="sc">'A'</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span> <span class="o">%</span> <span class="n">ALPHABET_SIZE</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="p">(</span><span class="n">character</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="n">shift</span><span class="p">)</span> <span class="o">%</span> <span class="n">ALPHABET_SIZE</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">character</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br>Encrypting Text with a Substitution Cipher</h3></header>
    









Write a C program <b>substitution.c</b> which reads characters from its input
and writes the  characters to its output encrypted with a <a href="https://en.wikipedia.org/wiki/Substitution_cipher">Substitution cipher</a>.
<p>
A <a href="https://en.wikipedia.org/wiki/Substitution_cipher">Substitution cipher</a> maps each letter to
another letter.
</p><p>
The mapping will be given to your program as a single command line argument.
This command line argument will contain 26 characters:
an ordering of the letters 'a'..'z'.
</p><p>
Characters other than letters should not be encrypted.
</p><p>
Your program should stop only at the end of input.
</p><p>
Your program should contain at least one function other than main.
</p><p>
For example:

</p><pre is="tty"><kbd is="sh">./substitution qwertyuiopasdfghjklzxcvbnm</kbd>
<kbd>I was scared of dentists and the dark</kbd>
O vql leqktr gy rtfzolzl qfr zit rqka
<kbd>I was scared of pretty girls and starting conversations</kbd>
O vql leqktr gy hktzzn uoksl qfr lzqkzofu egfctklqzogfl
<span class="eof"></span>
<kbd is="sh">./substitution abcdefghijklmnopqrstuvwxyz</kbd>
<kbd>The identity cipher!!!</kbd>
The identity cipher!!!
<span class="eof"></span>
<kbd is="sh">./substitution bcdefghijklmnopqrstuvwxyza</kbd>
<kbd>The Caesar cipher is a subset of the substitution cipher!</kbd>
Uif Dbftbs djqifs jt b tvctfu pg uif tvctujuvujpo djqifs!
<span class="eof"></span>
</pre>

Your program will only be tested with an appropriate command line argument -
but a good programmer would check the command line argument is present and appropriate.









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style substitution.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest substitution</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab07_substitution substitution.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Sunday 01 November 2020 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            </p><div class="answer">
                Sample solution for <code>substitution.c</code>
                
<div class="highlight"><pre><span></span><span class="c1">//  Written 3/3/2018 by Andrew Taylor (andrewt@unsw.edu.au)</span>
<span class="c1">//  Write stdin to stdout encrypted with a Substitution cipher</span>
<span class="c1">//  https://en.wikipedia.org/wiki/Substitution_cipher</span>
<span class="c1">//</span>
<span class="c1">//  The mapping will be supplied as a command-line argument containing 26 characters:</span>
<span class="c1">//  These will be an an ordering of the letters 'a'..'z'.</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cp">#define ALPHABET_SIZE  26</span>

<span class="kt">int</span> <span class="nf">encrypt</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">,</span> <span class="kt">char</span> <span class="n">mapping</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">]);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Usage: %s &lt;mapping&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="n">ALPHABET_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s: mapping must contain %d letters</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ALPHABET_SIZE</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">character</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">encrypted_character</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">character</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">putchar</span><span class="p">(</span><span class="n">encrypted_character</span><span class="p">);</span>
        <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// encrypt letters with a substitution cipher with the specified mapping</span>

<span class="kt">int</span> <span class="nf">encrypt</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">,</span> <span class="kt">char</span> <span class="n">mapping</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">character</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">mapping</span><span class="p">[</span><span class="n">character</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">character</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-self">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Challenge Exercise — individual:
    </small><br>Decrypting a Substitution Cipher</h3></header>
    









Write a C program <b>decode.c</b> which decrypts text encrypted by <b>substitution.c</b>
<p>
For example:

</p><pre is="tty"><kbd is="sh">./decode qwertyuiopasdfghjklzxcvbnm</kbd>
<kbd>O vql leqktr gy rtfzolzl qfr zit rqka</kbd>
I was scared of dentists and the dark
<kbd>O vql leqktr gy hktzzn uoksl qfr lzqkzofu egfctklqzogfl</kbd>
I was scared of pretty girls and starting conversations
<span class="eof"></span>
<kbd is="sh">./decode abcdefghijklmnopqrstuvwxyz</kbd>
<kbd>The identity cipher!!!</kbd>
The identity cipher!!!
<kbd is="sh">./decode bcdefghijklmnopqrstuvwxyza</kbd>
<kbd>Uif Dbftbs djqifs jt b tvctfu pg uif tvctujuvujpo djqifs!</kbd>
The Caesar cipher is a subset of the substitution cipher!
<span class="eof"></span>
</pre>

Your program will only be tested with an appropriate command line argument -
but a good programmer would check the command line argument is present and appropriate.

<h4>Manually Cracking a Substitution Cipher</h4>

This English  text was encrypted with a substitution cipher.

<pre>Di jd, vdl'ht xtqa dh O qn
Vdl rdlwk O'ss wdkith htqromu omkd ok
O fhdwqwsv xdm'k
Styk kd nv dxm rtzoetj
Wlk kiqk'j kit royythtmet om dlh dfomodmj

Vdl'ht q ndlkiyls
Kiqk qndlmkj ydh qmdkith xtta dm nv dxm
Mdx O'n q mdzts nqrt htjdlhetyls
O jkqhk q eiqom xoki nv kidluik

Kqsa oj eitqf, nv rqhsomu
Xitm vdl'ht yttsomu houik qk idnt
O xqmmq nqat vdl ndzt xoki edmyortmet
O xqmmq wt xoki vdl qsdmt
</pre>

What  was  the original text?
<p>
<b>Hint</b>: use <b>frequency_analysis.c</b> on the encrypted text and compare the frequencies
to <a href="https://en.wikipedia.org/wiki/Letter_frequency">English letter frequencies</a>
and then try your guesses with <b>decode.c</b>
</p><p>
</p><div class="answer">
Mapping: <b>qwertyuiopasnmdfghjklzxcvb</b>

<pre>Oh so, you're weak or I am
You doubt I'll bother reading into it
I probably won't
Left to my own devices
But that's the difference in our opinions

You're a mouthful
That amounts for another week on my own
Now I'm a novel made resourceful
I start a chain with my thought

Talk is cheap, my darling
When you're feeling right at home
I wanna make you move with confidence
I wanna be with you alone
</pre>

</div>









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style decode.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest decode</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you must

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab07_decode decode.c</kbd>
</pre>

<p>

You must run <code>give</code>

before <strong>Sunday 01 November 2020 20:00</strong>
to obtain the marks for this lab exercise.


Note that this is an individual exercise,
the work you submit with <code>give</code> must be entirely your own.





    
        
        
            
            </p><div class="answer">
                Sample solution for <code>decode.c</code>
                
<div class="highlight"><pre><span></span><span class="c1">//  Written 3/3/2018 by Andrew Taylor (andrewt@unsw.edu.au)</span>
<span class="c1">//  Write stdin to stdout decrypted with a Substitution cipher</span>
<span class="c1">//  https://en.wikipedia.org/wiki/Substitution_cipher</span>
<span class="c1">//</span>
<span class="c1">// The mapping used to encrypt the input</span>
<span class="c1">// will be supplied as a command-line argument containing 26 characters:</span>
<span class="c1">// These will be an an ordering of the letters 'a'..'z'.</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="cp">#define ALPHABET_SIZE 26</span>

<span class="kt">void</span> <span class="nf">compute_inverse_mapping</span><span class="p">(</span><span class="kt">char</span> <span class="n">mapping</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">],</span> <span class="kt">char</span> <span class="n">inverse_mapping</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">]);</span>
<span class="kt">int</span> <span class="nf">decrypt</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">,</span> <span class="kt">char</span>  <span class="n">inverse_mapping</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">]);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">inverse_mapping</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Usage: %s &lt;mapping&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="n">ALPHABET_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s: mapping must contain %d letters</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ALPHABET_SIZE</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">compute_inverse_mapping</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">inverse_mapping</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">character</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">decrypted_character</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">character</span><span class="p">,</span> <span class="n">inverse_mapping</span><span class="p">);</span>
        <span class="n">putchar</span><span class="p">(</span><span class="n">decrypted_character</span><span class="p">);</span>
        <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// mapping must contain an ordering of letters 'a'..'z'</span>
<span class="c1">// the inverse_mapping will be stored in inverse_mapping</span>

<span class="kt">void</span> <span class="nf">compute_inverse_mapping</span><span class="p">(</span><span class="kt">char</span> <span class="n">mapping</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">],</span> <span class="kt">char</span> <span class="n">inverse_mapping</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">ALPHABET_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">character</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">);</span>
        <span class="n">inverse_mapping</span><span class="p">[</span><span class="n">character</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// decrypt letters with a substitution cipher with the specified inverse_mapping</span>

<span class="kt">int</span> <span class="nf">decrypt</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">,</span> <span class="kt">char</span> <span class="n">inverse_mapping</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">inverse_mapping</span><span class="p">[</span><span class="n">character</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">inverse_mapping</span><span class="p">[</span><span class="n">character</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">character</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-self">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Challenge Exercise — individual:
    </small><br>Working Out the Letter Frequencies of Text</h3></header>
    









Write a C program <code>frequency_analysis.c</code> which reads characters from its input
until end of input.
<p>
It should then print the occurrence frequency for each of the 26 letters 'a'..'z'.
</p><p>
The frequency should be printed as a decimal value and an absolute number
in exactly the format below.
</p><p>
Note  upper and lower case letters are counted together.
</p><p>
For example:

</p><pre is="tty"><kbd is="sh">./frequency_analysis</kbd>
<kbd>Hello and goodbye.</kbd>
<span class="eof"></span>
'a' 0.066667 1
'b' 0.066667 1
'c' 0.000000 0
'd' 0.133333 2
'e' 0.133333 2
'f' 0.000000 0
'g' 0.066667 1
'h' 0.066667 1
'i' 0.000000 0
'j' 0.000000 0
'k' 0.000000 0
'l' 0.133333 2
'm' 0.000000 0
'n' 0.066667 1
'o' 0.200000 3
'p' 0.000000 0
'q' 0.000000 0
'r' 0.000000 0
's' 0.000000 0
't' 0.000000 0
'u' 0.000000 0
'v' 0.000000 0
'w' 0.000000 0
'x' 0.000000 0
'y' 0.066667 1
'z' 0.000000 0
<kbd is="sh">./frequency_analysis</kbd>
<kbd>Hey! Hey! Hey!
I don't like walking around this old and empty house
So hold my hand, I'll walk with you my dear</kbd>
<span class="eof"></span>
'a' 0.072289 6
'b' 0.000000 0
'c' 0.000000 0
'd' 0.084337 7
'e' 0.084337 7
'f' 0.000000 0
'g' 0.012048 1
'h' 0.096386 8
'i' 0.072289 6
'j' 0.000000 0
'k' 0.036145 3
'l' 0.084337 7
'm' 0.036145 3
'n' 0.060241 5
'o' 0.084337 7
'p' 0.012048 1
'q' 0.000000 0
'r' 0.024096 2
's' 0.036145 3
't' 0.048193 4
'u' 0.036145 3
'v' 0.000000 0
'w' 0.036145 3
'x' 0.000000 0
'y' 0.084337 7
'z' 0.000000 0
</pre>

<b>Hint</b>: hint use <code>getchar</code> to read characters (don't use <code>scanf</code> or <code>fgets</code>).
<p>
<b>Hint</b>: make sure you understand this <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/code/characters_and_strings/getchar_eof.c">example program</a> which reads characters until end of input.
</p><p>
<b>Hint</b>: use an array to store counts of each letter.
</p><p>
<b>Hint</b>: make sure you understand this  <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/code/arrays/integer_counter.c">example program</a> which counts integers from the range 0..99.


</p><h4>Manually Cracking a Substitution Cipher</h4>

This English text was encrypted with a substitution cipher.

<pre>Di jd, vdl'ht xtqa dh O qn
Vdl rdlwk O'ss wdkith htqromu omkd ok
O fhdwqwsv xdm'k
Styk kd nv dxm rtzoetj
Wlk kiqk'j kit royythtmet om dlh dfomodmj

Vdl'ht q ndlkiyls
Kiqk qndlmkj ydh qmdkith xtta dm nv dxm
Mdx O'n q mdzts nqrt htjdlhetyls
O jkqhk q eiqom xoki nv kidluik

Kqsa oj eitqf, nv rqhsomu
Xitm vdl'ht yttsomu houik qk idnt
O xqmmq nqat vdl ndzt xoki edmyortmet
O xqmmq wt xoki vdl qsdmt
</pre>

What  was  the original text?
<p>
<b>Hint</b>: use <b>frequency_analysis.c</b> on the encrypted text and compare the frequencies
to <a href="https://en.wikipedia.org/wiki/Letter_frequency">English letter frequencies</a>
and then try your guesses with <b>decode.c</b>
</p><p>
</p><div class="answer">
Mapping: <b>qwertyuiopasnmdfghjklzxcvb</b>

<pre>Oh so, you're weak or I am
You doubt I'll bother reading into it
I probably won't
Left to my own devices
But that's the difference in our opinions

You're a mouthful
That amounts for another week on my own
Now I'm a novel made resourceful
I start a chain with my thought

Talk is cheap, my darling
When you're feeling right at home
I wanna make you move with confidence
I wanna be with you alone
</pre>

</div>









<div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style frequency_analysis.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest frequency_analysis</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you must

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab07_frequency_analysis frequency_analysis.c</kbd>
</pre>

<p>

You must run <code>give</code>

before <strong>Sunday 01 November 2020 20:00</strong>
to obtain the marks for this lab exercise.


Note that this is an individual exercise,
the work you submit with <code>give</code> must be entirely your own.





    
        
        
            
            </p><div class="answer">
                Sample solution for <code>frequency_analysis.c</code>
                
<div class="highlight"><pre><span></span><span class="c1">//  Written 3/3/2018 by Andrew Taylor (andrewt@unsw.edu.au)</span>
<span class="c1">//  Read characters from stdin until of input then print the frequency of letters</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cp">#define NOT_A_LETTER   (-1)</span>
<span class="cp">#define ALPHABET_SIZE  26</span>

<span class="kt">int</span> <span class="nf">get_letter_frequencies</span><span class="p">(</span><span class="kt">int</span> <span class="n">letter_count</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">]);</span>
<span class="kt">int</span> <span class="nf">letter_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print_frequencies</span><span class="p">(</span><span class="kt">int</span> <span class="n">letter_count</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">],</span> <span class="kt">int</span> <span class="n">n_letters_read</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">letter_count</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>  <span class="c1">// 1 array element for each English letter</span>

    <span class="kt">int</span> <span class="n">n_letters_read</span> <span class="o">=</span> <span class="n">get_letter_frequencies</span><span class="p">(</span><span class="n">letter_count</span><span class="p">);</span>
    <span class="n">print_frequencies</span><span class="p">(</span><span class="n">letter_count</span><span class="p">,</span> <span class="n">n_letters_read</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// read  characters from stdin, and for uppercase and lower case letters updating</span>
<span class="c1">// accumulating count a letter_count in letter_frequencies</span>
<span class="c1">// number of uppercase and lower case letters read is returned</span>

<span class="kt">int</span> <span class="nf">get_letter_frequencies</span><span class="p">(</span><span class="kt">int</span> <span class="n">letter_count</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">n_letters_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">character</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span>  <span class="n">letter_index</span><span class="p">(</span><span class="n">character</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">NOT_A_LETTER</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">letter_count</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">letter_count</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">n_letters_read</span> <span class="o">=</span> <span class="n">n_letters_read</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">n_letters_read</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// return position of letter in English  alphabet (0..25)</span>
<span class="c1">// for lower case and upper case letter</span>
<span class="c1">// return NOT_A_LETTER for other characters</span>

<span class="kt">int</span> <span class="nf">letter_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">character</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">'A'</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">'Z'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">character</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">character</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">character</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">NOT_A_LETTER</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_frequencies</span><span class="p">(</span><span class="kt">int</span> <span class="n">letter_count</span><span class="p">[</span><span class="n">ALPHABET_SIZE</span><span class="p">],</span> <span class="kt">int</span> <span class="n">n_letters_read</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n_letters_read</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">ALPHABET_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"'%c' %lf %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="sc">'a'</span><span class="o">+</span><span class="n">i</span><span class="p">,</span> <span class="n">letter_count</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">n_letters_read</span><span class="p">,</span>  <span class="n">letter_count</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-self">
    <header><h3>Extra-hard challenge: Cracking A Substitution Cipher (individual - attempt if you dare)</h3></header>
    









Write a C program <b>crack_substitution.c</b> which decrypts text encrypted by an unknown
s cipher.
<p>
Your program should make no assumptions about the language of the original text - don't assume its English.
In other words don't hard code English properties into your program,
extract the statistical properties from the sample plain text.
However, you can assume the English alphabet ('a'..'z').
</p><p>
Your program will be given as its first line of input the name of a file containing a large amount of
unencrypted text in the same language as the encrypted text.
</p><p>
For example for example your program might be given  <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/crack_substitution/wiki_sentences.txt">this file</a> containing 188k characters of English text
<small>(wikipedia sentences from <a href="https://github.com/CrowdTruth/Short-Text-Corpus-For-Humor-Detection">here</a>)</small>
Your program will be given the encrypted text on the next lines.
You may read it all before printing the decryption.
</p><p>
For example:

</p><pre is="tty"><kbd is="sh">./crack_substitution</kbd>
<kbd>wiki_sentences.txt</kbd>
<kbd>M'ka paat dra qegbu, ueta md xbb
Rxu vw fxya teq
Umxvetup, ogmbbmxtd, mt Oab-Xmg teq
Red psvvag tmlrdp, vmu Jsbw
Qrat wes xtu M qaga negakag qmbu
Dra fgxzw uxwp, fmdw bmlrdp
Dra qxw wes'u cbxw qmdr va bmya x frmbu
Qmbb wes pdmbb beka va
Qrat M'v te betlag westl xtu oaxsdmnsb?
Qmbb wes pdmbb beka va
Qrat M'ka led tedrmtl osd vw xfrmtl pesb?
M yteq wes qmbb, M yteq wes qmbb
M yteq drxd wes qmbb
Qmbb wes pdmbb beka va qrat M'v te betlag oaxsdmnsb?
M'ka paat dra qegbu, bmd md sc
Xp vw pdxla teq
Frxbbatlmtl xtlabp mt x taq xla teq
Red psvvag uxwp, gefy t gebb
Dra qxw wes cbxw neg va xd wesg preq
Xtu xbb dra qxwp, M led de yteq
Wesg cgaddw nxfa xtu abafdgmf pesb</kbd>
<span class="eof"></span>
I've seen the world, done it all
Had my cake now
Diamonds, brilliant, in Bel-Air now
Hot summer nights, mid July
When you and I were forever wild
The crazy days, city lights
The way you'd play with me like a child
Will you still love me
When I'm no longer young and beautiful?
Will you still love me
When I've got nothing but my aching soul?
I know you will, I know you will
I know that you will
Will you still love me when I'm no longer beautiful?
I've seen the world, lit it up
As my stage now
Challenging angels in a new age now
Hot summer days, rock n roll
The way you play for me at your show
And all the ways, I got to know
Your pretty face and electric soul
</pre>

You may assume the filename given on the first line of input is at most 1000 characters.
<p>
You may assume the  encrypted text on stdin contains at most 10000 characters.
</p><p>
You may assume the unencrypted example text in the file  contains at most 250000 characters.
</p><p>
<b>Hint</b>: you will need to look at the probabilities of sequences of 2 or
perhaps 3 letters occurring or perhaps the probabilities of words.
</p><p>
<b>Hint</b>: use <code>fopen</code> to open the file and <code>fgetc</code> to read the file. 
These won't be covered in lectures, so read this <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/code/reading_and_writing_files/cat_fgetc.c">
example program</a> to see how to use this functions to read a file.
</p><p>
An autotest is available to help you test your program but because this is a difficult problem it
is possible very good attempts at the problem won't pass the autotests.









</p><div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style crack_substitution.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest crack_substitution</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you must

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab07_crack_substitution crack_substitution.c</kbd>
</pre>

<p>

You must run <code>give</code>

before <strong>Sunday 01 November 2020 20:00</strong>
to obtain the marks for this lab exercise.


Note that this is an individual exercise,
the work you submit with <code>give</code> must be entirely your own.





    
        
        
            
            </p><div class="answer">
                Sample solution for <code>crack_substitution.c</code>
                
<div class="highlight"><pre><span></span><span class="c1">// crack_substitution.c</span>
<span class="c1">// Andrew Bennett</span>
<span class="c1">// 2018-04-15</span>
<span class="c1">// Edited by Marc Chee (21/10/2019)</span>

<span class="c1">// Write a C program crack_substitution.c which decrypts text encrypted</span>
<span class="c1">// by an unknown cipher.</span>
<span class="c1">// Your program should make no assumptions about the language of the</span>
<span class="c1">// original text - don't assume it's English. In other words don't hard</span>
<span class="c1">// code English properties into your program, extract the statistical</span>
<span class="c1">// properties from the sample plain text. However, you can assume the</span>
<span class="c1">// English alphabet ('a'..'z').</span>
<span class="c1">//</span>
<span class="c1">// Your program will be given as a command-line argument the name of a</span>
<span class="c1">// file containing a large amount of unencrypted text in the same</span>
<span class="c1">// language as the encrypted text.</span>
<span class="c1">//</span>
<span class="c1">// Your program will be given the encrypted text on standard input. You</span>
<span class="c1">// may read it all before printing the decryption.</span>
<span class="c1">//</span>
<span class="c1">// You may assume the encrypted text contains at most 10000 characters.</span>

<span class="c1">// The key idea behind this approach is based around "n-grams" --</span>
<span class="c1">// collections of n letters. The frequency of n-grams in English is</span>
<span class="c1">// useful in determining whether we've managed to decode our ciphertext</span>
<span class="c1">// into something English -- i.e. we know that "the" / "ing" are far</span>
<span class="c1">// more likely to be valid n-grams (in this case trigrams) than say</span>
<span class="c1">// "jwq".</span>
<span class="c1">//</span>
<span class="c1">// With this, we don't need a word list containing possible valid</span>
<span class="c1">// English words -- this is especially important given that the words</span>
<span class="c1">// in the ciphertext may not appear in our corpus at all.</span>

<span class="c1">// Approach:</span>
<span class="c1">//   - calculate n-grams for the known unencrypted text</span>
<span class="c1">//   - generate a random "key" for the cipher; apply it to the ciphertext</span>
<span class="c1">//   - calculate n-grams for that deciphered text</span>
<span class="c1">//   - compare its n-grams with the "base" n-grams; calculate a</span>
<span class="c1">//     "goodness" score</span>
<span class="c1">//   - change the key by swapping every possible pair of characters;</span>
<span class="c1">//     keep track of the "best" result</span>
<span class="c1">//   - rinse and repeat until we're unable to get a "better" result</span>
<span class="c1">//</span>
<span class="c1">// This won't always find the correct decryption, so we repeat the entire</span>
<span class="c1">// process multiple times, keeping track of the very best overall key,</span>
<span class="c1">// and using that at the end to print our final result.</span>

<span class="cp">#include</span> <span class="cpf">&lt;ctype.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;time.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="c1">// Set this to 1 if you'd like to see the "progress" (it's pretty cool</span>
<span class="c1">// to watch)</span>
<span class="cp">#define DEBUG 0</span>

<span class="cp">#define MAX_FILENAME 1000</span>
<span class="cp">#define MAX_CIPHER_SIZE 10001</span>
<span class="cp">#define MAX_WORD_SIZE 1001</span>
<span class="cp">#define N_LETTERS 26</span>

<span class="cp">#define END_OF_INDICES -1</span>

<span class="cp">#define TRUE 1</span>
<span class="cp">#define FALSE 0</span>

<span class="cp">#define MAX_ATTEMPTS 20</span>

<span class="cp">#define REALLY_BAD -1000000</span>

<span class="c1">// used when deciding if two doubles are "equal"</span>
<span class="cp">#define EPSILON 0.000001</span>

<span class="c1">// Getting the ciphertext (from stdin)</span>

<span class="kt">void</span> <span class="nf">get_ciphertext</span><span class="p">(</span><span class="kt">char</span> <span class="n">raw_ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span>
                    <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">]);</span>
<span class="kt">void</span> <span class="nf">print_ciphertext</span><span class="p">(</span><span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">]);</span>

<span class="c1">// Reading (and processing) the unencrypted corpus</span>

<span class="kt">void</span> <span class="nf">process_corpus_ngrams</span><span class="p">(</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]);</span>

<span class="kt">void</span> <span class="nf">get_corpus_ngrams</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">corpus_unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                       <span class="kt">int</span> <span class="n">corpus_bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                       <span class="kt">int</span> <span class="n">corpus_trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]);</span>

<span class="kt">void</span> <span class="nf">count_ngrams</span><span class="p">(</span><span class="kt">int</span> <span class="n">unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">total_unigrams</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">total_bigrams</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                  <span class="kt">int</span> <span class="o">*</span><span class="n">total_trigrams</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">calculate_ngram_log_frequencies</span><span class="p">(</span>
        <span class="kt">double</span> <span class="n">unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="n">unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="n">total_unigrams</span><span class="p">,</span>
        <span class="kt">double</span> <span class="n">bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="n">bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">int</span> <span class="n">total_bigrams</span><span class="p">,</span> <span class="kt">double</span> <span class="n">trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">int</span> <span class="n">trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="n">total_trigrams</span><span class="p">);</span>

<span class="c1">// Extract the next word from the input stream / ciphertext array.</span>

<span class="kt">int</span> <span class="nf">get_word</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">]);</span>
<span class="kt">int</span> <span class="nf">get_next_ciphertext_word</span><span class="p">(</span><span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span>
                             <span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">],</span> <span class="kt">int</span> <span class="n">upto</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">get_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print_indices</span><span class="p">(</span><span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">]);</span>

<span class="c1">// Calculating the n-grams for a given word</span>

<span class="kt">void</span> <span class="nf">determine_ngrams</span><span class="p">(</span><span class="kt">int</span> <span class="n">unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">]);</span>

<span class="kt">void</span> <span class="nf">print_ngrams</span><span class="p">(</span><span class="kt">int</span> <span class="n">unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                  <span class="kt">int</span> <span class="n">bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                  <span class="kt">int</span> <span class="n">trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]);</span>

<span class="kt">void</span> <span class="nf">get_guess_ngrams</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">guess_unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">guess_bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">guess_trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]);</span>

<span class="kt">void</span> <span class="nf">cipher_indices</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">],</span>
                    <span class="kt">int</span> <span class="n">ciphered_indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">]);</span>

<span class="c1">// Cracking the cipher!</span>

<span class="kt">void</span> <span class="nf">determine_key</span><span class="p">(</span><span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span> <span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                   <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                   <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                   <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]);</span>

<span class="kt">double</span> <span class="nf">do_one_attempt</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">best_key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]);</span>

<span class="kt">double</span> <span class="nf">get_best_permutation</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">best_key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">double</span> <span class="n">best_goodness</span><span class="p">,</span>
    <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span> <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]);</span>

<span class="c1">// Calculate the "goodness" of a given guess</span>

<span class="kt">double</span> <span class="nf">calculate_goodness</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]);</span>

<span class="kt">double</span> <span class="nf">compare_ngrams</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">guess_unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">int</span> <span class="n">guess_bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">int</span> <span class="n">guess_trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]);</span>

<span class="kt">double</span> <span class="nf">log_frequency</span><span class="p">(</span><span class="kt">int</span> <span class="n">count_ngram</span><span class="p">,</span> <span class="kt">double</span> <span class="n">log10_total_ngrams</span><span class="p">);</span>

<span class="c1">// Decode the ciphertext!</span>

<span class="kt">void</span> <span class="nf">decode_ciphertext</span><span class="p">(</span><span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span> <span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">]);</span>

<span class="kt">int</span> <span class="nf">decode</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">]);</span>

<span class="c1">// Misc helper functions</span>

<span class="kt">void</span> <span class="nf">print_key</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">]);</span>
<span class="kt">void</span> <span class="nf">copy_key</span><span class="p">(</span><span class="kt">int</span> <span class="n">key_to</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="n">key_from</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">]);</span>
<span class="kt">void</span> <span class="nf">generate_random_permutation</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">]);</span>
<span class="kt">void</span> <span class="nf">flip</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">is_lowercase</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">goodness_equals</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Step 0: Read filename</span>
    <span class="kt">char</span> <span class="n">file</span><span class="p">[</span><span class="n">MAX_FILENAME</span><span class="p">];</span>
    <span class="n">fgets</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">MAX_FILENAME</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
    <span class="c1">// strip the \n from the end of file</span>
    <span class="n">file</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    
    <span class="c1">// Step 1: get the ciphertext.</span>
    <span class="c1">//</span>
    <span class="c1">// Store two different "versions" of the ciphertext:</span>
    <span class="c1">//   - a processed version with only spaces and lowercase letters</span>
    <span class="c1">//     (uppercase letters are converted to lowercase)</span>
    <span class="c1">//</span>
    <span class="c1">//   - the "raw" ciphertext -- exactly character-for-character what</span>
    <span class="c1">//     we read from stdin.</span>
    <span class="c1">//</span>
    <span class="c1">// This means that we can do operations on the simplified version,</span>
    <span class="c1">// without ever having to worry again about what case is it, is it a</span>
    <span class="c1">// valid letter, etc etc.</span>
    <span class="c1">//</span>
    <span class="c1">// But, since we need to print out the deciphered version of the</span>
    <span class="c1">// full original plaintext (punctuation and all), we need to store</span>
    <span class="c1">// the "raw" ciphertext, which we will apply the deciphering to</span>
    <span class="c1">// later.</span>
    <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">raw_ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">];</span>
    <span class="n">get_ciphertext</span><span class="p">(</span><span class="n">raw_ciphertext</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">);</span>

    <span class="c1">// Step 2: Calculate some statistics about the unencrypted text.</span>
    <span class="c1">//</span>
    <span class="c1">// We intentionally don't store the text itself, and just read it</span>
    <span class="c1">// from the file as necessary to generate statistics -- this is</span>
    <span class="c1">// because we might have a HUGE corpus that wouldn't fit in memory,</span>
    <span class="c1">// but from which we could still get useful data.</span>
    <span class="c1">//</span>
    <span class="c1">// Specifically, we calculate the log-frequency of each of the</span>
    <span class="c1">// n-grams in the provided corpus of unencrypted text.</span>
    <span class="c1">// We store these directly, rather than storing the count of</span>
    <span class="c1">// n-grams, since it will save us a lot of CPU time later.</span>
    <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">0</span><span class="p">}};</span>
    <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{{</span><span class="mi">0</span><span class="p">}}};</span>
    <span class="n">process_corpus_ngrams</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">corpus_unigrams_lf</span><span class="p">,</span> <span class="n">corpus_bigrams_lf</span><span class="p">,</span>
                          <span class="n">corpus_trigrams_lf</span><span class="p">);</span>

    <span class="c1">// Step 3: Calculate the "key" for our ciphertext.</span>
    <span class="c1">//</span>
    <span class="c1">// This is the mapping of letters, i.e. 'a' in the encrypted text is</span>
    <span class="c1">// 'r' in the original plaintext (etc).</span>
    <span class="c1">//</span>
    <span class="c1">// To make it simpler, we store the numbers 0-25 rather than the</span>
    <span class="c1">// letters 'a' to 'z'.</span>
    <span class="c1">//</span>
    <span class="c1">// So, if key[0] was 5, that means that 'a' (the first letter of the</span>
    <span class="c1">// alphabet) maps to 'f' (the sixth letter of the alphabet).</span>

    <span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">determine_key</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">corpus_unigrams_lf</span><span class="p">,</span> <span class="n">corpus_bigrams_lf</span><span class="p">,</span>
                  <span class="n">corpus_trigrams_lf</span><span class="p">);</span>

    <span class="c1">// Step 4: Decode the (raw) ciphertext back into the original</span>
    <span class="c1">// plaintext.</span>
    <span class="n">decode_ciphertext</span><span class="p">(</span><span class="n">raw_ciphertext</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//              GETTING THE CIPHERTEXT (FROM STDIN)                   //</span>
<span class="c1">////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// Get the ciphertext (from standard input), and store two versions of</span>
<span class="c1">// it into the provided arrays -- "raw_ciphertext" is the raw,</span>
<span class="c1">// unprocessed version of the text we read in, "ciphertext" is the</span>
<span class="c1">// processed version (with punctuation etc removed, and all letters</span>
<span class="c1">// lowercase).</span>
<span class="kt">void</span> <span class="nf">get_ciphertext</span><span class="p">(</span><span class="kt">char</span> <span class="n">raw_ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span>
                    <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">])</span> <span class="p">{</span>

    <span class="c1">// Keep track of where we're up to in the "raw ciphertext", as well</span>
    <span class="c1">// as where we're up to in the processed ciphertext.</span>
    <span class="c1">//</span>
    <span class="c1">// We need two separate variables because we don't want to leave</span>
    <span class="c1">// gaps in the processed version where we've removed characters from</span>
    <span class="c1">// the raw version.</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c_upto</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">c</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CIPHER_SIZE</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">())</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">raw_ciphertext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
        <span class="c1">// If it's a space or a letter, copy it to our processed</span>
        <span class="c1">// ciphertext array.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">||</span> <span class="n">isalpha</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// tolower will make uppercase lower, and leave lowercase</span>
            <span class="c1">// and space unchanged.</span>
            <span class="n">ciphertext</span><span class="p">[</span><span class="n">c_upto</span><span class="p">]</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="n">c_upto</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Put a null terminator at the end of our strings, so that we know</span>
    <span class="c1">// where they end!</span>
    <span class="n">ciphertext</span><span class="p">[</span><span class="n">c_upto</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
    <span class="n">raw_ciphertext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// A simple function to print out the ciphertext -- always useful to</span>
<span class="c1">// check that you've correctly obtained your input before you move on</span>
<span class="c1">// any further with your code.</span>
<span class="kt">void</span> <span class="nf">print_ciphertext</span><span class="p">(</span><span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">])</span> <span class="p">{</span>
    <span class="n">fputs</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//           READING + PROCESSING THE UNENCRYPTED CORPUS              //</span>
<span class="c1">////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// Calculate some statistics about the provided unencrypted text</span>
<span class="c1">// ("corpus").</span>
<span class="c1">// We intentionally don't store the text itself, and just read it</span>
<span class="c1">// from the file as necessary to generate statistics -- this is</span>
<span class="c1">// because we might have a HUGE corpus that wouldn't fit in memory,</span>
<span class="c1">// but from which we could still get useful data.</span>
<span class="c1">//</span>
<span class="c1">// We process the plaintext word-by-word (because we care about trigrams</span>
<span class="c1">// within a word -- the spaces between words are important!), and so</span>
<span class="c1">// this function will extract the next word from the input stream, and</span>
<span class="c1">// process its trigrams, then extract the next word and process it, etc</span>
<span class="c1">// etc.</span>
<span class="kt">void</span> <span class="nf">process_corpus_ngrams</span><span class="p">(</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>

    <span class="c1">// Arrays to store the n-grams in.</span>
    <span class="kt">int</span> <span class="n">corpus_unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">corpus_bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">0</span><span class="p">}};</span>
    <span class="kt">int</span> <span class="n">corpus_trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{{</span><span class="mi">0</span><span class="p">}}};</span>

    <span class="c1">// Actually get the input, and calculate the ngrams.</span>
    <span class="n">get_corpus_ngrams</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">corpus_unigrams</span><span class="p">,</span> <span class="n">corpus_bigrams</span><span class="p">,</span>
                      <span class="n">corpus_trigrams</span><span class="p">);</span>

    <span class="c1">// Now, calculate the log-frequencies of each n-gram, i.e.</span>
    <span class="c1">// log(count_of_this_ngram / total_ngrams).</span>
    <span class="c1">//</span>
    <span class="c1">// In order to do that, we need to know how many n-grams we have...</span>
    <span class="c1">// It's much nicer to be able to count the ngrams all in one go --</span>
    <span class="c1">// but to return three values, we need to use pointers (or structs)</span>
    <span class="kt">int</span> <span class="n">total_unigrams</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">total_bigrams</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">total_trigrams</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">count_ngrams</span><span class="p">(</span><span class="n">corpus_unigrams</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total_unigrams</span><span class="p">,</span>
                 <span class="n">corpus_bigrams</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total_bigrams</span><span class="p">,</span>
                 <span class="n">corpus_trigrams</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">total_trigrams</span><span class="p">);</span>

    <span class="c1">// And, finally, calculate the log-frequencies of each n-gram.</span>
    <span class="c1">// These get stored in the corpus ngram log-frequency arrays we were</span>
    <span class="c1">// passed into this function.</span>
    <span class="n">calculate_ngram_log_frequencies</span><span class="p">(</span>
        <span class="n">corpus_unigrams_lf</span><span class="p">,</span> <span class="n">corpus_unigrams</span><span class="p">,</span> <span class="n">total_unigrams</span><span class="p">,</span>
        <span class="n">corpus_bigrams_lf</span><span class="p">,</span> <span class="n">corpus_bigrams</span><span class="p">,</span> <span class="n">total_bigrams</span><span class="p">,</span>
        <span class="n">corpus_trigrams_lf</span><span class="p">,</span> <span class="n">corpus_trigrams</span><span class="p">,</span> <span class="n">total_trigrams</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Work through the input, calculating the n-grams for each word.</span>
<span class="kt">void</span> <span class="nf">get_corpus_ngrams</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">corpus_unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                       <span class="kt">int</span> <span class="n">corpus_bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                       <span class="kt">int</span> <span class="n">corpus_trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>

    <span class="kt">FILE</span> <span class="o">*</span><span class="n">input</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"r"</span><span class="p">);</span>

    <span class="c1">// When calculating the statistics, we don't actually care about</span>
    <span class="c1">// the letters being letters -- so we turn letters into numbers</span>
    <span class="c1">// between 0 and 25, where 0 is lowercase or uppercase 'a', and 25</span>
    <span class="c1">// is 'z' or 'Z'.</span>
    <span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="c1">// We only consider one word at a time -- since we care about</span>
    <span class="c1">// identifying words in our ciphertext (spaces are important!)</span>
    <span class="c1">//</span>
    <span class="c1">// This will get a word from stdin, then fill the `indices` array</span>
    <span class="c1">// with the indices for that word (i.e. 'a'/'A' would be represented</span>
    <span class="c1">// with a 0, etc.</span>
    <span class="c1">//</span>
    <span class="c1">// We then calculate the trigrams for that word, updating the</span>
    <span class="c1">// results in our trigrams array we've passed in from main.</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">get_word</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Update our n-gram statistics with the n-grams from the</span>
        <span class="c1">// current word.</span>
        <span class="n">determine_ngrams</span><span class="p">(</span><span class="n">corpus_unigrams</span><span class="p">,</span>
                         <span class="n">corpus_bigrams</span><span class="p">,</span>
                         <span class="n">corpus_trigrams</span><span class="p">,</span> <span class="n">indices</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// print_ngrams(corpus_unigrams, corpus_bigrams, corpus_trigrams);</span>
<span class="p">}</span>

<span class="c1">// Count the number of unigrams/bigrams/trigrams in the text.</span>
<span class="kt">void</span> <span class="nf">count_ngrams</span><span class="p">(</span><span class="kt">int</span> <span class="n">unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">total_unigrams</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="o">*</span><span class="n">total_bigrams</span><span class="p">,</span>
                  <span class="kt">int</span> <span class="n">trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                  <span class="kt">int</span> <span class="o">*</span><span class="n">total_trigrams</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// Something particularly noteworthy here -- we don't run the inner</span>
    <span class="c1">// loop to check for bigrams starting with `i`, unless we have any</span>
    <span class="c1">// unigrams of `i`; and we don't run the inner-inner loop to check</span>
    <span class="c1">// for trigrams starting with `ij` unless we have any bigrams of</span>
    <span class="c1">// `ij`.</span>
    <span class="c1">// This cuts down on a LOT of extra processing overhead -- for</span>
    <span class="c1">// example, let's say we're looking at trigrams that start with</span>
    <span class="c1">// "zx". If there aren't any trigrams at all that start with "zx",</span>
    <span class="c1">// then we've wasted our time doing 26 unnecessary inner iterations</span>
    <span class="c1">// checking for "zxa" "zxb" "zxc" etc.</span>
    <span class="c1">// This might not sound like much, but its adds up -- adding the</span>
    <span class="c1">// check here to not try counting trigrams unless we have bigrams</span>
    <span class="c1">// made the code run about twice as fast. :+1:</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If we do actually have any unigrams of `i` (aka `i` appeared</span>
        <span class="c1">// in the plaintext at all), then increase our counter and check</span>
        <span class="c1">// for bigrams</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unigrams</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// *total_unigrams, because total_unigrams is a pointer to</span>
            <span class="c1">// the variable back in the "process_corpus_ngrams" function.</span>
            <span class="o">*</span><span class="n">total_unigrams</span> <span class="o">+=</span> <span class="n">unigrams</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// If we do actually have any bigrams of [i][j] (aka the</span>
                <span class="c1">// letters "ij" appeared together at any point in the</span>
                <span class="c1">// plaintext), then keep looking for trigrams.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">bigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="o">*</span><span class="n">total_bigrams</span> <span class="o">+=</span> <span class="n">bigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">trigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
                            <span class="o">*</span><span class="n">total_trigrams</span> <span class="o">+=</span> <span class="n">trigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
                        <span class="p">}</span>
                        <span class="n">k</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">j</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Go through all of the corpus's ngrams that we've now counted,</span>
<span class="c1">// and calculate the log-frequency for each of those ngrams.</span>
<span class="c1">//</span>
<span class="c1">// (note: this function prototype/signature is SO GROSS -- nine</span>
<span class="c1">// parameters??? split across more than nine lines??!?? this is why I</span>
<span class="c1">// used a struct in my original code, so that I could pass around a</span>
<span class="c1">// struct pointer rather than having to have such massively long</span>
<span class="c1">// function signatures. bleh.)</span>
<span class="c1">//</span>
<span class="c1">// On the bright side, pre-calculating these rather than trying to</span>
<span class="c1">// calculate them over and over again each time we calculate the</span>
<span class="c1">// "goodness" of a guess makes things a lot faster.</span>
<span class="kt">void</span> <span class="nf">calculate_ngram_log_frequencies</span><span class="p">(</span>
        <span class="c1">// unigrams</span>
        <span class="kt">double</span> <span class="n">unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">int</span> <span class="n">unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">int</span> <span class="n">total_unigrams</span><span class="p">,</span>
        <span class="c1">// bigrams</span>
        <span class="kt">double</span> <span class="n">bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">int</span> <span class="n">bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">int</span> <span class="n">total_bigrams</span><span class="p">,</span>
        <span class="c1">// trigrams</span>
        <span class="kt">double</span> <span class="n">trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">int</span> <span class="n">trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">int</span> <span class="n">total_trigrams</span><span class="p">)</span> <span class="p">{</span>

    <span class="kt">double</span> <span class="n">log10_unigrams</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">total_unigrams</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">log10_bigrams</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">total_bigrams</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">log10_trigrams</span> <span class="o">=</span> <span class="n">log10</span><span class="p">(</span><span class="n">total_trigrams</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Calculate the log-frequency of these unigrams</span>
        <span class="n">unigrams_lf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_frequency</span><span class="p">(</span><span class="n">unigrams</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">log10_unigrams</span><span class="p">);</span>

        <span class="c1">// Check for bigrams</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">bigrams_lf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">log_frequency</span><span class="p">(</span><span class="n">bigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">log10_bigrams</span><span class="p">);</span>

            <span class="c1">// Check for trigrams</span>
            <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">trigrams_lf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span>
                    <span class="n">log_frequency</span><span class="p">(</span><span class="n">trigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="n">log10_trigrams</span><span class="p">);</span>
                <span class="n">k</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//              EXTRACT WORDS FROM THE INPUT/CIPHERTEXT               //</span>
<span class="c1">////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// Get the next word from `input`, returns length of word or EOF</span>
<span class="c1">// word = letters, converted to lowercase</span>
<span class="c1">// any non-letters are ignored</span>
<span class="c1">// any whitespace terminates the word (and is not included)</span>
<span class="kt">int</span> <span class="nf">get_word</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">input</span><span class="p">,</span> <span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">])</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">found_eof</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_WORD_SIZE</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Get the next character.</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">fgetc</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

        <span class="c1">// If it's EOF, we're done with all of the text.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">found_eof</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// If it's whitespace, we're at the end of the word.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isspace</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">done</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
            <span class="c1">// Note that we can't null terminate our indices array,</span>
            <span class="c1">// because 0 is a valid value (i.e. the letter a).</span>
            <span class="c1">// Instead, we have a "custom" null terminator equivalent.</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">END_OF_INDICES</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// If it's alpha, add it to the word</span>
        <span class="c1">// If it's not alpha, do nothing.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
            <span class="n">i</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// We already did this above -- if we hit the end of the loop</span>
    <span class="c1">// because we got more than MAX_WORD_SIZE then we didn't do it, so</span>
    <span class="c1">// let's do it again just to be safe..</span>
    <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">END_OF_INDICES</span><span class="p">;</span>

    <span class="c1">// i = word length</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">found_eof</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">EOF</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Get the next word from the ciphertext. Takes in the ciphertext</span>
<span class="c1">// overall, the position we're up to within the ciphertext, and an</span>
<span class="c1">// "indices" array to fill with the indices for the word we extract</span>
<span class="c1">// (where "indices" is a mapping of A-&gt;0, B-&gt;1, .. Z-&gt;25.</span>
<span class="kt">int</span> <span class="nf">get_next_ciphertext_word</span><span class="p">(</span><span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span>
                             <span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">],</span> <span class="kt">int</span> <span class="n">upto</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// We're currently up to "upto", so look from here until we find a</span>
    <span class="c1">// word. Words are terminated by spaces -- we're working from our</span>
    <span class="c1">// processed ciphertext, and so we know it only has lowercase</span>
    <span class="c1">// letters and spaces (and a null terminator at the end).</span>

    <span class="c1">// Keeps track of where we're up to in the indices array.</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">ciphertext</span><span class="p">[</span><span class="n">upto</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isspace</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">[</span><span class="n">upto</span><span class="p">]))</span> <span class="p">{</span>
        <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_index</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">[</span><span class="n">upto</span><span class="p">]);</span>
        <span class="n">upto</span><span class="o">++</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Don't forget to put the terminator back on the word!</span>
    <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">END_OF_INDICES</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ciphertext</span><span class="p">[</span><span class="n">upto</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">upto</span> <span class="o">=</span> <span class="n">END_OF_INDICES</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// Move `upto` along to the start of the next word.</span>
        <span class="n">upto</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">upto</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Takes in a letter (uppercase or lowercase), returns the index of that</span>
<span class="c1">// letter within the alphabet (i.e. 'a' / 'A' is 0, 'z' / 'Z' is 25).</span>
<span class="kt">int</span> <span class="nf">get_index</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Make it lowercase -- easier to deal with just one case</span>
    <span class="c1">// (avoids needing an if statement to check whether upper/lowercase</span>
    <span class="c1">// and subtracting 'A' or 'a')</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

    <span class="c1">// Subtract 'a' from the letter: so 'a' - 'a' is 0, 'b' - 'a' is 1,</span>
    <span class="c1">// 'z' - 'a' is 25, etc.</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Print out the indices, as numbers.</span>
<span class="kt">void</span> <span class="nf">print_indices</span><span class="p">(</span><span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">END_OF_INDICES</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//             CALCULATING THE N-GRAMS FOR A GIVEN WORD               //</span>
<span class="c1">////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// Returns the length of the word it's processed</span>
<span class="kt">void</span> <span class="nf">determine_ngrams</span><span class="p">(</span><span class="kt">int</span> <span class="n">unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">])</span> <span class="p">{</span>

    <span class="c1">// Store the current letter, the previous letter, and the</span>
    <span class="c1">// previous-previous (prev1) letter.</span>
    <span class="kt">int</span> <span class="n">curr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">prev</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">prev1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">END_OF_INDICES</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="n">unigrams</span><span class="p">[</span><span class="n">curr</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// If prev is positive, then we've hit our second letter.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">bigrams</span><span class="p">[</span><span class="n">prev</span><span class="p">][</span><span class="n">curr</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// If prev1 is positive, then we've hit our third letter.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prev1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">trigrams</span><span class="p">[</span><span class="n">prev1</span><span class="p">][</span><span class="n">prev</span><span class="p">][</span><span class="n">curr</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Shuffle them along, so our current letter is now our previous</span>
        <span class="c1">// letter, and our previous letter is now our previous-previous</span>
        <span class="c1">// letter.</span>
        <span class="n">prev1</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Always useful to be able to sanity check that the data we've gathered</span>
<span class="c1">// looks correct.</span>
<span class="kt">void</span> <span class="nf">print_ngrams</span><span class="p">(</span><span class="kt">int</span> <span class="n">unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                  <span class="kt">int</span> <span class="n">bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                  <span class="kt">int</span> <span class="n">trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"looking at unigrams:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unigrams</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%c: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">,</span> <span class="n">unigrams</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"looking at bigrams:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"%c%c: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">,</span> <span class="n">bigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"looking at trigrams:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">trigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"%c%c%c: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">,</span> <span class="n">k</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">,</span>
                           <span class="n">trigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]);</span>
                <span class="p">}</span>
                <span class="n">k</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Work out the n-grams for our current guess, given a key and the</span>
<span class="c1">// ciphertext (and some arrays to store the ngrams in).</span>
<span class="c1">// This applies the decryption key to the ciphertext, and then calls the</span>
<span class="c1">// pre-existing "determine_ngrams" function that we've already used for</span>
<span class="c1">// the provided unencrypted text.</span>
<span class="kt">void</span> <span class="nf">get_guess_ngrams</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">guess_unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">guess_bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                      <span class="kt">int</span> <span class="n">guess_trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>

    <span class="c1">// We have our current guess: the ciphertext, and a key</span>
    <span class="c1">// (mapping of A-&gt;Z).</span>
    <span class="c1">//</span>
    <span class="c1">// We need to get a word to pass to our determine_ngrams function.</span>
    <span class="c1">//</span>
    <span class="c1">// A "word" means the next word we're up to in the ciphertext,</span>
    <span class="c1">// permuted with the key.</span>
    <span class="c1">//</span>
    <span class="c1">// So -- get the next word out, get the indices for it,</span>
    <span class="c1">// apply the permutation to those, pass that into determine_ngrams</span>
    <span class="c1">//</span>
    <span class="c1">// The only underlying difference is in how it gets a word</span>
    <span class="c1">// -- and at the end of the day, we really just want an indices</span>
    <span class="c1">// array.</span>

    <span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">ciphered_indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="kt">int</span> <span class="n">upto</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Get the next word, and store it in the "indices" array.</span>
        <span class="c1">// returns the starting position of the next word in the array,</span>
        <span class="c1">// or END_OF_INDICES if we've reached the end of the ciphertext.</span>
        <span class="n">upto</span> <span class="o">=</span> <span class="n">get_next_ciphertext_word</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">upto</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">upto</span> <span class="o">==</span> <span class="n">END_OF_INDICES</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">done</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">cipher_indices</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">ciphered_indices</span><span class="p">);</span>

            <span class="n">determine_ngrams</span><span class="p">(</span><span class="n">guess_unigrams</span><span class="p">,</span> <span class="n">guess_bigrams</span><span class="p">,</span> <span class="n">guess_trigrams</span><span class="p">,</span>
                             <span class="n">ciphered_indices</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Apply the cipher (key) to each of the indices in the array, storing</span>
<span class="c1">// them in the "ciphered_indices" array.</span>
<span class="kt">void</span> <span class="nf">cipher_indices</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="n">indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">],</span>
                    <span class="kt">int</span> <span class="n">ciphered_indices</span><span class="p">[</span><span class="n">MAX_WORD_SIZE</span><span class="p">])</span> <span class="p">{</span>

    <span class="c1">// key is an array of size 26, where key[0] is what A should</span>
    <span class="c1">// be, key[1] is what B should be, etc.</span>
    <span class="c1">//</span>
    <span class="c1">// We want to thus "cipher" each index as appropriate -- i.e.</span>
    <span class="c1">// work out which value it should be according to our key.</span>

    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">END_OF_INDICES</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ciphered_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Make sure we put the terminator back on!</span>
    <span class="n">ciphered_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">END_OF_INDICES</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//               CRACKING THE CIPHER!                                 //</span>
<span class="c1">////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// Works out the correct decryption key for the ciphertext, and puts it</span>
<span class="c1">// in "key".</span>
<span class="c1">//</span>
<span class="c1">// To calculate the "correct key", we start out by generating some</span>
<span class="c1">// random key, and then flipping every possible pair of characters to</span>
<span class="c1">// form a new key.</span>
<span class="c1">// We then measure how "good" a given key is, and use the best of the</span>
<span class="c1">// keys to continue on, and flip every possible pair of characters in</span>
<span class="c1">// that key, etc etc, until we can't find a better solution.</span>
<span class="c1">//</span>
<span class="c1">// However, this doesn't always get us the correct answer, so we repeat</span>
<span class="c1">// this overall process some number of times, keeping track of the</span>
<span class="c1">// overall best key we've found.</span>
<span class="c1">//</span>
<span class="c1">// The number of iterations we do there is determined by the time limit</span>
<span class="c1">// we have when running under `dcc --valgrind` -- I think we can get</span>
<span class="c1">// away with 5 attempts?</span>
<span class="kt">void</span> <span class="nf">determine_key</span><span class="p">(</span><span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span> <span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                   <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
                   <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
                   <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>

    <span class="c1">// Seed the random number generator.</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>

    <span class="kt">double</span> <span class="n">best_goodness</span> <span class="o">=</span> <span class="n">REALLY_BAD</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">current_attempt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Try to generate a key several times, to increase the likelihood</span>
    <span class="c1">// of actually getting the right answer.</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current_attempt</span> <span class="o">&lt;</span> <span class="n">MAX_ATTEMPTS</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Do one overall attempt -- i.e. generate a random key, and</span>
        <span class="c1">// iterate over that key until we can't make it any better.</span>

        <span class="c1">// Store the best key we've found in this attempt.</span>
        <span class="kt">int</span> <span class="n">best_key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">];</span>
        <span class="kt">double</span> <span class="n">goodness</span> <span class="o">=</span>
            <span class="n">do_one_attempt</span><span class="p">(</span><span class="n">best_key</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">,</span> <span class="n">corpus_unigrams_lf</span><span class="p">,</span>
                           <span class="n">corpus_bigrams_lf</span><span class="p">,</span> <span class="n">corpus_trigrams_lf</span><span class="p">);</span>

        <span class="c1">// If the new key we've found is better than our overall best</span>
        <span class="c1">// key, update our overall best key.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">goodness</span> <span class="o">&gt;</span> <span class="n">best_goodness</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">best_goodness</span> <span class="o">=</span> <span class="n">goodness</span><span class="p">;</span>
            <span class="n">copy_key</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">best_key</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">decode_ciphertext</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">current_attempt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This does an overall attempt (which we do a few of, since one doesn't</span>
<span class="c1">// always do the best)</span>
<span class="kt">double</span> <span class="nf">do_one_attempt</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">best_key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span>
        <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>

    <span class="c1">// Current mapping of A-Z</span>
    <span class="kt">int</span> <span class="n">current_key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">];</span>

    <span class="c1">// fill this with a randomly generated key</span>
    <span class="n">generate_random_permutation</span><span class="p">(</span><span class="n">current_key</span><span class="p">);</span>

    <span class="c1">// Start out with some impossibly-bad initial value for our "best goodness",</span>
    <span class="c1">// so that we know as soon as we do our first calculation it will be the</span>
    <span class="c1">// best so far.</span>
    <span class="kt">double</span> <span class="n">best_goodness</span> <span class="o">=</span> <span class="n">REALLY_BAD</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">attempt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Do one iteration over this current key -- i.e. try swapping</span>
        <span class="c1">// every possible pair of characters within the key.</span>
        <span class="kt">double</span> <span class="n">goodness</span> <span class="o">=</span> <span class="n">get_best_permutation</span><span class="p">(</span>
            <span class="n">current_key</span><span class="p">,</span> <span class="n">best_goodness</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">,</span> <span class="n">corpus_unigrams_lf</span><span class="p">,</span>
            <span class="n">corpus_bigrams_lf</span><span class="p">,</span> <span class="n">corpus_trigrams_lf</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// printf("KEY: "); print_key(current_key);</span>
            <span class="c1">// printf("GOODNESS: %lf\n", goodness);</span>
        <span class="p">}</span>
        <span class="c1">// If this is the same as our current best, then we've found the</span>
        <span class="c1">// best that we can (i.e. the "local maxima") -- it might not be</span>
        <span class="c1">// the best solution overall, but we're not going to find</span>
        <span class="c1">// anything better.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">goodness_equals</span><span class="p">(</span><span class="n">goodness</span><span class="p">,</span> <span class="n">best_goodness</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"DONE!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">done</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// If we've the key we've found is better than the best, then</span>
        <span class="c1">// use this one -- but we know that we've gotten the best key</span>
        <span class="c1">// back from `inner` so this is unnecessary?</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">goodness</span> <span class="o">&gt;</span> <span class="n">best_goodness</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">best_goodness</span> <span class="o">=</span> <span class="n">goodness</span><span class="p">;</span>
            <span class="c1">// copy the best key into the default</span>
            <span class="n">copy_key</span><span class="p">(</span><span class="n">best_key</span><span class="p">,</span> <span class="n">current_key</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span>
                <span class="n">decode_ciphertext</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">,</span> <span class="n">best_key</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">attempt</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">best_goodness</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Needs to have the key that it's starting from, and the key that it's</span>
<span class="c1">// temporarily working with (which it can store itself?)</span>
<span class="c1">// Need to store the starting key (which can also be the best key?)</span>
<span class="c1">// separately (because we need to be able to update)</span>
<span class="kt">double</span> <span class="nf">get_best_permutation</span><span class="p">(</span>
    <span class="kt">int</span> <span class="n">best_key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">double</span> <span class="n">best_goodness</span><span class="p">,</span>
    <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span> <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
    <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">current_guess</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">];</span>
    <span class="c1">// Start out with the best key we know about thus far, and iterate</span>
    <span class="c1">// on that.</span>
    <span class="n">copy_key</span><span class="p">(</span><span class="n">current_guess</span><span class="p">,</span> <span class="n">best_key</span><span class="p">);</span>

    <span class="c1">// Try flipping every possible pair of letters.</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Flip the indices at pos i, j.</span>
                <span class="n">flip</span><span class="p">(</span><span class="n">current_guess</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>

                <span class="c1">// Determine the "goodness" of this current guess, based</span>
                <span class="c1">// on how well the n-gram distribution matches that of</span>
                <span class="c1">// the unencrypted corpus we were given.</span>
                <span class="kt">double</span> <span class="n">goodness</span> <span class="o">=</span> <span class="n">calculate_goodness</span><span class="p">(</span>
                    <span class="n">current_guess</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">,</span> <span class="n">corpus_unigrams_lf</span><span class="p">,</span>
                    <span class="n">corpus_bigrams_lf</span><span class="p">,</span> <span class="n">corpus_trigrams_lf</span><span class="p">);</span>

                <span class="c1">// If this current guess is better, update our</span>
                <span class="c1">// best_goodness and copy it into best_key.</span>
                <span class="c1">// note that we're comparing to the overall goodness</span>
                <span class="c1">// across this attempt, since we want to be getting</span>
                <span class="c1">// better each time, rather than starting from scratch.</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">goodness</span> <span class="o">&gt;</span> <span class="n">best_goodness</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">copy_key</span><span class="p">(</span><span class="n">best_key</span><span class="p">,</span> <span class="n">current_guess</span><span class="p">);</span>
                    <span class="n">best_goodness</span> <span class="o">=</span> <span class="n">goodness</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">// Flip them back, so that we're starting from scratch</span>
                <span class="c1">// with our next attempt.</span>
                <span class="n">flip</span><span class="p">(</span><span class="n">current_guess</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Return the new best goodness that we've found, so that the parent</span>
    <span class="c1">// function can decide whether to use this new key.</span>
    <span class="k">return</span> <span class="n">best_goodness</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//           CALCULATING THE "GOODNESS" OF A GIVEN GUESS              //</span>
<span class="c1">////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// Calculates the "goodness" of the current guess. This is done by</span>
<span class="c1">// comparing the frequencies of the ngram distribution of this</span>
<span class="c1">// ciphertext vs the frequencies of the provided corpus of unencrypted</span>
<span class="c1">// text.</span>
<span class="kt">double</span> <span class="nf">calculate_goodness</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span>
        <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
        <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>

    <span class="kt">int</span> <span class="n">guess_unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">guess_bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">0</span><span class="p">}};</span>
    <span class="kt">int</span> <span class="n">guess_trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{{{</span><span class="mi">0</span><span class="p">}}};</span>

    <span class="n">get_guess_ngrams</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">,</span> <span class="n">guess_unigrams</span><span class="p">,</span> <span class="n">guess_bigrams</span><span class="p">,</span>
                     <span class="n">guess_trigrams</span><span class="p">);</span>

    <span class="kt">double</span> <span class="n">goodness</span> <span class="o">=</span> <span class="n">compare_ngrams</span><span class="p">(</span><span class="n">guess_unigrams</span><span class="p">,</span> <span class="n">guess_bigrams</span><span class="p">,</span>
                                     <span class="n">guess_trigrams</span><span class="p">,</span> <span class="n">corpus_unigrams_lf</span><span class="p">,</span>
                                     <span class="n">corpus_bigrams_lf</span><span class="p">,</span> <span class="n">corpus_trigrams_lf</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">goodness</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Compare the unigram distribution in the guess to the unigram</span>
<span class="c1">// distribution in the corpus of unencrypted text.</span>
<span class="c1">// This works by summing (the log-frequency of that unigram in the</span>
<span class="c1">// corpus of unencrypted text) for each unigram in the ciphertext.</span>
<span class="c1">// (That wasn't explained very well, so just bear with me....)</span>
<span class="kt">double</span>
<span class="nf">compare_ngrams</span><span class="p">(</span><span class="kt">int</span> <span class="n">guess_unigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
               <span class="kt">int</span> <span class="n">guess_bigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
               <span class="kt">int</span> <span class="n">guess_trigrams</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
               <span class="kt">double</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span>
               <span class="kt">double</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">],</span>
               <span class="kt">double</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">][</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>

    <span class="kt">double</span> <span class="n">difference</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Time for another one of these fantastic massive n^3 loops....</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Only keep going if we have this unigram in the guess</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">guess_unigrams</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">difference</span> <span class="o">+=</span> <span class="n">corpus_unigrams_lf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">guess_unigrams</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Only keep going if we have this bigram in the guess</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">guess_bigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
                    <span class="n">difference</span> <span class="o">+=</span> <span class="n">corpus_bigrams_lf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">guess_bigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
                    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">guess_trigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
                            <span class="n">difference</span> <span class="o">+=</span> <span class="n">corpus_trigrams_lf</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span>
                                          <span class="n">guess_trigrams</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
                        <span class="p">}</span>
                        <span class="n">k</span><span class="o">++</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="n">j</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">difference</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Calculate log10 of the frequency of this ngram -- the number of times</span>
<span class="c1">// this ngram occurred divided by the total ngrams.</span>
<span class="kt">double</span> <span class="nf">log_frequency</span><span class="p">(</span><span class="kt">int</span> <span class="n">count_ngram</span><span class="p">,</span> <span class="kt">double</span> <span class="n">log10_total_ngrams</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">value</span> <span class="o">=</span> <span class="n">count_ngram</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count_ngram</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">value</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// The calculation here is log10(value/total_ngrams).</span>
    <span class="c1">// We speed this up in two ways:</span>
    <span class="c1">//   - log10(value) - log10(total_ngrams)</span>
    <span class="c1">//   - pre-calculating log10(total_ngrams) rather than recalculating</span>
    <span class="k">return</span> <span class="n">log10</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">-</span> <span class="n">log10_total_ngrams</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//                 DECODE THE CIPHERTEXT!                             //</span>
<span class="c1">////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// Run through the entire ciphertext, decoding it with the specified key.</span>
<span class="kt">void</span> <span class="nf">decode_ciphertext</span><span class="p">(</span><span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">MAX_CIPHER_SIZE</span><span class="p">],</span> <span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_CIPHER_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">decode</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">key</span><span class="p">);</span>
        <span class="n">putchar</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Decode a single character 'c', given the key.</span>
<span class="kt">int</span> <span class="nf">decode</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// The decoded character is the character itself, unless...</span>
    <span class="kt">int</span> <span class="n">decoded</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

    <span class="c1">// ... it's a letter, in which case we do need to decode it.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isalpha</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_lowercase</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="n">decoded</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">'A'</span><span class="p">;</span>
            <span class="n">decoded</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="sc">'A'</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">decoded</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">////////////////////////////////////////////////////////////////////////</span>
<span class="c1">//                MISC HELPER FUNCTIONS                               //</span>
<span class="c1">////////////////////////////////////////////////////////////////////////</span>

<span class="c1">// Print out a key, converting the numbers to letters.</span>
<span class="kt">void</span> <span class="nf">print_key</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="sc">'a'</span> <span class="o">+</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Copy the values from one key to another.</span>
<span class="kt">void</span> <span class="nf">copy_key</span><span class="p">(</span><span class="kt">int</span> <span class="n">key_to</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="n">key_from</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">key_to</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key_from</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Generates a random permutation of values; stores it in "key".</span>
<span class="c1">// The random permutation is done using the "Fisher–Yates shuffle".</span>
<span class="kt">void</span> <span class="nf">generate_random_permutation</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">N_LETTERS</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">rand_index</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">N_LETTERS</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">rand_index</span><span class="p">];</span>
        <span class="n">key</span><span class="p">[</span><span class="n">rand_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Swaps the elements at index i and j.</span>
<span class="kt">void</span> <span class="nf">flip</span><span class="p">(</span><span class="kt">int</span> <span class="n">key</span><span class="p">[</span><span class="n">N_LETTERS</span><span class="p">],</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="n">key</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">is_lowercase</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="sc">'a'</span> <span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Since we can't compare doubles for equality, instead we check if</span>
<span class="c1">// they're "close enough".</span>
<span class="kt">int</span> <span class="nf">goodness_equals</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">EPSILON</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>





<section class="exercise ">
    <header><h3>Submission</h3></header>
    


When you are finished each exercises make sure you submit your work by running <code>give</code>.
<p>
You can run <code>give</code> multiple times.
Only your last submission will be marked.
</p><p>
Don't submit any exercises you haven't attempted.
</p><p>
If you are working at home, you may find it more convenient
to upload your work via
<a href="https://cgi.cse.unsw.edu.au/~give/Student/give.php">give's web interface</a>.
</p><p>
Remember you have until

<b>Week 7 Sunday 20:00</b>

to submit your work.
</p><p>
You cannot obtain marks by e-mailing your code to tutors or lecturers.
</p><p>
You check the files you have submitted <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">here</a>.
</p><p>
Automarking will be run by the lecturer several days after the submission deadline,
using test cases different to those <code>autotest</code> runs for you.
(Hint: do your own testing as well as running <code>autotest</code>.)
</p><p>
After automarking is run by the lecturer
you can <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">view your results here</a>.
The resulting mark will also be available
<a href="https://cgi.cse.unsw.edu.au/~give/Student/sturec.php">via give's web interface</a>.

</p><h4>Lab Marks</h4>
<p>
When all components of a lab  are automarked you should be able to view the
the marks <a href="https://cgi.cse.unsw.edu.au/~give/Student/sturec.php">via give's web interface</a>
or by running this command on a CSE machine:

</p><pre is="tty"><kbd is="sh">1511 classrun -sturec</kbd>
</pre>










    </section>


</div>



</main>

<footer class="mt-3 pt-3 bg-dark text-center no-print">
<p class="text-muted">
<strong>COMP1511 20T3: Programming Fundamentals</strong>
is brought to you by <br>
the <a href="https://www.cse.unsw.edu.au/">School of Computer Science and Engineering</a><br>
at the <a href="https://www.unsw.edu.au/">University of New South Wales</a>, Sydney.<br>
For all enquiries, please email the class account at
<a href="mailto:@cse.unsw.edu.au">cs1511@cse.unsw.edu.au</a><br>

<small>CRICOS Provider 00098G</small>
</p>


</footer>


</body></html>