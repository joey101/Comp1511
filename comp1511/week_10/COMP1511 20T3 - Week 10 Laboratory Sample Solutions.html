<!DOCTYPE html>
<!-- saved from url=(0055)https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/10/answers -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

<title>
    
    COMP1511 20T3 - 
Week 10
Laboratory
Sample Solutions

    
</title><link rel="canonical" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/">

<link rel="stylesheet" href="./COMP1511 20T3 - Week 10 Laboratory Sample Solutions_files/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
<link rel="stylesheet" href="./COMP1511 20T3 - Week 10 Laboratory Sample Solutions_files/course.css">

<script src="./COMP1511 20T3 - Week 10 Laboratory Sample Solutions_files/jquery.min.js.download" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="./COMP1511 20T3 - Week 10 Laboratory Sample Solutions_files/popper.min.js.download" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
<script src="./COMP1511 20T3 - Week 10 Laboratory Sample Solutions_files/bootstrap.min.js.download" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
<script src="./COMP1511 20T3 - Week 10 Laboratory Sample Solutions_files/course.js.download"></script>


<link rel="icon" type="image/png" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/flask.cgi/static/favicon.ico?1271605745352.0">

<!-- <script async src="https://static.codepen.io/assets/embed/ei.js"></script> -->

<!-- MathJax. -->






<style>
body {
    background-image:url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' height='50px' width='220px'><text x='0' y='15' fill='red' font-size='20' opacity='0.2'>  [OLD - 20T3]  </text></svg>");
}
</style>

<script type="text/javascript" async="" src="./COMP1511 20T3 - Week 10 Laboratory Sample Solutions_files/MathJax.js.download"></script><style type="text/css">.MathJax_Hover_Frame {border-radius: .25em; -webkit-border-radius: .25em; -moz-border-radius: .25em; -khtml-border-radius: .25em; box-shadow: 0px 0px 15px #83A; -webkit-box-shadow: 0px 0px 15px #83A; -moz-box-shadow: 0px 0px 15px #83A; -khtml-box-shadow: 0px 0px 15px #83A; border: 1px solid #A6D ! important; display: inline-block; position: absolute}
.MathJax_Menu_Button .MathJax_Hover_Arrow {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 4px; -webkit-border-radius: 4px; -moz-border-radius: 4px; -khtml-border-radius: 4px; font-family: 'Courier New',Courier; font-size: 9px; color: #F0F0F0}
.MathJax_Menu_Button .MathJax_Hover_Arrow span {display: block; background-color: #AAA; border: 1px solid; border-radius: 3px; line-height: 0; padding: 4px}
.MathJax_Hover_Arrow:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_Hover_Arrow:hover span {background-color: #CCC!important}
</style><style type="text/css">#MathJax_About {position: fixed; left: 50%; width: auto; text-align: center; border: 3px outset; padding: 1em 2em; background-color: #DDDDDD; color: black; cursor: default; font-family: message-box; font-size: 120%; font-style: normal; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; border-radius: 15px; -webkit-border-radius: 15px; -moz-border-radius: 15px; -khtml-border-radius: 15px; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_About.MathJax_MousePost {outline: none}
.MathJax_Menu {position: absolute; background-color: white; color: black; width: auto; padding: 2px; border: 1px solid #CCCCCC; margin: 0; cursor: default; font: menu; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; z-index: 201; box-shadow: 0px 10px 20px #808080; -webkit-box-shadow: 0px 10px 20px #808080; -moz-box-shadow: 0px 10px 20px #808080; -khtml-box-shadow: 0px 10px 20px #808080; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
.MathJax_MenuItem {padding: 2px 2em; background: transparent}
.MathJax_MenuArrow {position: absolute; right: .5em; padding-top: .25em; color: #666666; font-size: .75em}
.MathJax_MenuActive .MathJax_MenuArrow {color: white}
.MathJax_MenuArrow.RTL {left: .5em; right: auto}
.MathJax_MenuCheck {position: absolute; left: .7em}
.MathJax_MenuCheck.RTL {right: .7em; left: auto}
.MathJax_MenuRadioCheck {position: absolute; left: 1em}
.MathJax_MenuRadioCheck.RTL {right: 1em; left: auto}
.MathJax_MenuLabel {padding: 2px 2em 4px 1.33em; font-style: italic}
.MathJax_MenuRule {border-top: 1px solid #CCCCCC; margin: 4px 1px 0px}
.MathJax_MenuDisabled {color: GrayText}
.MathJax_MenuActive {background-color: Highlight; color: HighlightText}
.MathJax_MenuDisabled:focus, .MathJax_MenuLabel:focus {background-color: #E8E8E8}
.MathJax_ContextMenu:focus {outline: none}
.MathJax_ContextMenu .MathJax_MenuItem:focus {outline: none}
#MathJax_AboutClose {top: .2em; right: .2em}
.MathJax_Menu .MathJax_MenuClose {top: -10px; left: -10px}
.MathJax_MenuClose {position: absolute; cursor: pointer; display: inline-block; border: 2px solid #AAA; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; font-family: 'Courier New',Courier; font-size: 24px; color: #F0F0F0}
.MathJax_MenuClose span {display: block; background-color: #AAA; border: 1.5px solid; border-radius: 18px; -webkit-border-radius: 18px; -moz-border-radius: 18px; -khtml-border-radius: 18px; line-height: 0; padding: 8px 0 6px}
.MathJax_MenuClose:hover {color: white!important; border: 2px solid #CCC!important}
.MathJax_MenuClose:hover span {background-color: #CCC!important}
.MathJax_MenuClose:hover:focus {outline: none}
</style><style type="text/css">.MathJax_Preview .MJXf-math {color: inherit!important}
</style><style type="text/css">.MJX_Assistive_MathML {position: absolute!important; top: 0; left: 0; clip: rect(1px, 1px, 1px, 1px); padding: 1px 0 0 0!important; border: 0!important; height: 1px!important; width: 1px!important; overflow: hidden!important; display: block!important; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none}
.MJX_Assistive_MathML.MJX_Assistive_MathML_Block {width: 100%!important}
</style><style type="text/css">#MathJax_Zoom {position: absolute; background-color: #F0F0F0; overflow: auto; display: block; z-index: 301; padding: .5em; border: 1px solid black; margin: 0; font-weight: normal; font-style: normal; text-align: left; text-indent: 0; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box; box-shadow: 5px 5px 15px #AAAAAA; -webkit-box-shadow: 5px 5px 15px #AAAAAA; -moz-box-shadow: 5px 5px 15px #AAAAAA; -khtml-box-shadow: 5px 5px 15px #AAAAAA; filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}
#MathJax_ZoomOverlay {position: absolute; left: 0; top: 0; z-index: 300; display: inline-block; width: 100%; height: 100%; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
#MathJax_ZoomFrame {position: relative; display: inline-block; height: 0; width: 0}
#MathJax_ZoomEventTrap {position: absolute; left: 0; top: 0; z-index: 302; display: inline-block; border: 0; padding: 0; margin: 0; background-color: white; opacity: 0; filter: alpha(opacity=0)}
</style><style type="text/css">.MathJax_Preview {color: #888}
#MathJax_Message {position: fixed; left: 1em; bottom: 1.5em; background-color: #E6E6E6; border: 1px solid #959595; margin: 0px; padding: 2px 8px; z-index: 102; color: black; font-size: 80%; width: auto; white-space: nowrap}
#MathJax_MSIE_Frame {position: absolute; top: 0; left: 0; width: 0px; z-index: 101; border: 0px; margin: 0px; padding: 0px}
.MathJax_Error {color: #CC0000; font-style: italic}
</style><style type="text/css">.MJXp-script {font-size: .8em}
.MJXp-right {-webkit-transform-origin: right; -moz-transform-origin: right; -ms-transform-origin: right; -o-transform-origin: right; transform-origin: right}
.MJXp-bold {font-weight: bold}
.MJXp-italic {font-style: italic}
.MJXp-scr {font-family: MathJax_Script,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-frak {font-family: MathJax_Fraktur,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-sf {font-family: MathJax_SansSerif,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-cal {font-family: MathJax_Caligraphic,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-mono {font-family: MathJax_Typewriter,'Times New Roman',Times,STIXGeneral,serif}
.MJXp-largeop {font-size: 150%}
.MJXp-largeop.MJXp-int {vertical-align: -.2em}
.MJXp-math {display: inline-block; line-height: 1.2; text-indent: 0; font-family: 'Times New Roman',Times,STIXGeneral,serif; white-space: nowrap; border-collapse: collapse}
.MJXp-display {display: block; text-align: center; margin: 1em 0}
.MJXp-math span {display: inline-block}
.MJXp-box {display: block!important; text-align: center}
.MJXp-box:after {content: " "}
.MJXp-rule {display: block!important; margin-top: .1em}
.MJXp-char {display: block!important}
.MJXp-mo {margin: 0 .15em}
.MJXp-mfrac {margin: 0 .125em; vertical-align: .25em}
.MJXp-denom {display: inline-table!important; width: 100%}
.MJXp-denom > * {display: table-row!important}
.MJXp-surd {vertical-align: top}
.MJXp-surd > * {display: block!important}
.MJXp-script-box > *  {display: table!important; height: 50%}
.MJXp-script-box > * > * {display: table-cell!important; vertical-align: top}
.MJXp-script-box > *:last-child > * {vertical-align: bottom}
.MJXp-script-box > * > * > * {display: block!important}
.MJXp-mphantom {visibility: hidden}
.MJXp-munderover, .MJXp-munder {display: inline-table!important}
.MJXp-over {display: inline-block!important; text-align: center}
.MJXp-over > * {display: block!important}
.MJXp-munderover > *, .MJXp-munder > * {display: table-row!important}
.MJXp-mtable {vertical-align: .25em; margin: 0 .125em}
.MJXp-mtable > * {display: inline-table!important; vertical-align: middle}
.MJXp-mtr {display: table-row!important}
.MJXp-mtd {display: table-cell!important; text-align: center; padding: .5em 0 0 .5em}
.MJXp-mtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-mlabeledtr {display: table-row!important}
.MJXp-mlabeledtr > .MJXp-mtd:first-child {padding-left: 0}
.MJXp-mlabeledtr:first-child > .MJXp-mtd {padding-top: 0}
.MJXp-merror {background-color: #FFFF88; color: #CC0000; border: 1px solid #CC0000; padding: 1px 3px; font-style: normal; font-size: 90%}
.MJXp-scale0 {-webkit-transform: scaleX(.0); -moz-transform: scaleX(.0); -ms-transform: scaleX(.0); -o-transform: scaleX(.0); transform: scaleX(.0)}
.MJXp-scale1 {-webkit-transform: scaleX(.1); -moz-transform: scaleX(.1); -ms-transform: scaleX(.1); -o-transform: scaleX(.1); transform: scaleX(.1)}
.MJXp-scale2 {-webkit-transform: scaleX(.2); -moz-transform: scaleX(.2); -ms-transform: scaleX(.2); -o-transform: scaleX(.2); transform: scaleX(.2)}
.MJXp-scale3 {-webkit-transform: scaleX(.3); -moz-transform: scaleX(.3); -ms-transform: scaleX(.3); -o-transform: scaleX(.3); transform: scaleX(.3)}
.MJXp-scale4 {-webkit-transform: scaleX(.4); -moz-transform: scaleX(.4); -ms-transform: scaleX(.4); -o-transform: scaleX(.4); transform: scaleX(.4)}
.MJXp-scale5 {-webkit-transform: scaleX(.5); -moz-transform: scaleX(.5); -ms-transform: scaleX(.5); -o-transform: scaleX(.5); transform: scaleX(.5)}
.MJXp-scale6 {-webkit-transform: scaleX(.6); -moz-transform: scaleX(.6); -ms-transform: scaleX(.6); -o-transform: scaleX(.6); transform: scaleX(.6)}
.MJXp-scale7 {-webkit-transform: scaleX(.7); -moz-transform: scaleX(.7); -ms-transform: scaleX(.7); -o-transform: scaleX(.7); transform: scaleX(.7)}
.MJXp-scale8 {-webkit-transform: scaleX(.8); -moz-transform: scaleX(.8); -ms-transform: scaleX(.8); -o-transform: scaleX(.8); transform: scaleX(.8)}
.MJXp-scale9 {-webkit-transform: scaleX(.9); -moz-transform: scaleX(.9); -ms-transform: scaleX(.9); -o-transform: scaleX(.9); transform: scaleX(.9)}
.MathJax_PHTML .noError {vertical-align: ; font-size: 90%; text-align: left; color: black; padding: 1px 3px; border: 1px solid}
</style></head>
<body class="d-flex flex-column vsc-initialized" style="min-height: 100vh;"><div id="MathJax_Message" style="display: none;"></div>
  <nav class="navbar fixed-top navbar-expand-lg navbar-light no-print" id="header-navbar">
  <div class="container">
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse" data-target="#navmenu" aria-controls="navmenu" aria-label="Toggle navigation" aria-expanded="false">
      <span class="navbar-toggler-icon"></span>
    </button>

    <a class="navbar-brand" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/">
      COMP1511 20T3
    </a>

    <div class="collapse navbar-collapse" id="navmenu">
      <ul class="navbar-nav mr-auto">
        <li class="nav-item active"><a class="nav-link" href="https://discourse.cse.unsw.edu.au/20t3/comp1511/">Forum</a></li>
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">Submissions</a></li>
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/history/">History</a></li>

        
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/assignments/ass1/index.html">Assignment 1</a></li>
        

        
        <li class="nav-item active"><a class="nav-link" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/assignments/ass2/index.html">Assignment 2</a></li>
        

        <li class="navbar-text px-2">|</li>
        


    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
            
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    

    


<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="week-selector" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/10/answers#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Week 10 <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="week-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/01/answers">Week 01</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/02/answers">Week 02</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/03/answers">Week 03</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/04/answers">Week 04</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/05/answers">Week 05</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/06/answers">Week 06 (tutors only)</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/07/answers">Week 07</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/08/answers">Week 08</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/09/answers">Week 09</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/10/answers">Week 10</a>
  </div>
</li>



    
        
        
        
        
    

    
        
        
        
        
    

    
        
        
        
        
    


<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="tlb-selector" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/10/answers#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Laboratory <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="tlb-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/tut/10/answers">Tutorial</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/10/answers">Laboratory</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/test/10/answers">Weekly Test</a>
  </div>
</li>



    
    
    
    

    
    
    
    



<li class="nav-item active dropdown">
  <a role="button" class="nav-link dropdown-toggle" id="qa-selector" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/10/answers#" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
    Sample Solutions <span class="caret"></span>
  </a>
  <div class="dropdown-menu" aria-labelledby="qa-selector">
  
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/10/questions">Exercises</a>
    <a class="dropdown-item" href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/lab/10/answers">Sample Solutions</a>
  </div>
</li>


      </ul>
    </div>
  </div>
</nav>


<main class="container" aria-label="Content" style="flex: 1; padding-top: 4rem;">


<header>

<h1 class="text-center">
Week 10
Laboratory
Sample Solutions
</h1>

</header>


<div class="tutlab lab">




<section class="exercise ">
    <header><h3>Objectives</h3></header>
    

<ul>

<li>Become familiar with the  environment used for the final exam</li>

<li>practice coding under exam conditions</li>

</ul>


    </section>








<h3>MyExperience</h3>
<p>
The first 10 minutes of the lab is set aside for you to complete the
<a href="https://myexperience.unsw.edu.au/">myExperience survey</a> for COMP1511.
Your answers are confidential and you should not show them to your tutor.
</p><p>
</p><h3>Take-Home Exam Practice</h3>
<p>
The first three lab exercises must be completed and submitted using the instructions
for submission of the exam (the questions themselves will have these instructions).
</p><p>
This section of the lab will not be run under full exam conditions or time limits
but it will be a good chance for you to familiarise yourself with how the questions 
will be structured as well as how auto testing and submission works.
</p><p>
Remember that in the exam you are allowed to look up resources, but you are not
allowed to communicate with anyone (inside or outside the course) about the exam.
If you like, you can try these exercises with those restrictions so that you have
some familiarity with the format.

</p><h3>Practice Exam Part 1</h3>
<p>
Part 1 of the exam is a series of short questions that don't involve you writing code,
but instead you interpreting code or understanding some key concepts.
</p><p>
You will be answering part 1 by editing a text file that you can test and submit.
The test will only tell you if your answers are understood, not if they're correct.
</p><p>
The real exam will have more part 1 questions!
</p><p>
Your answers for part 1 questions in today's practice exam will not be marked.
</p><p>

</p><h3>Practice Exam Part 2</h3>
<p>
The first three of this week's lab exercises are the Part 2 questions for the practice exam.
</p><p>
Part 2 answers are entered into the file specified by each question, autotested using the <code>1511 autotest-pracexam</code> command,
and submitted using the "give" command. 
The questions include submission instructions.
</p><p>
We are not enforcing exam conditions but try to do the questions under simulated exam conditions.
</p><p>
If you can't complete the questions, you can talk to your tutors.
</p><p>
Your answers will be automarked in the usual way for lab exercises.

</p><h3>Accessing the Prac Exam Environment</h3>

<p>
To access the Prac Exam, go to: <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/prac_exam/papers/">https://cgi.cse.unsw.edu.au/~cs1511/20T3/prac_exam/papers/</a>.
</p><p>
    You will be asked to enter your zID and zPass. You will then be taken to your personal exam paper.
</p><p>
    In the final exam, this paper will be personalized to you.

</p><h3>Returning to normal lab work</h3>
<p>
The remaining lab exercises are completed the usual way.

</p><div class="answers">

<h3>MC Sample Solution</h3>
<p>Part 1 Q1: 3</p>
<p>Part 1 Q2: AB</p>
<p>Part 1 Q3: <code>sizeof(struct node)</code></p>

</div>





 






    


<section class="exercise with-self">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — individual:
    </small><br>Practice Exam Q1 - Count the number of small values in an 2D array</h3></header>
    









Your task is to add code to this function:


<div class="highlight"><pre><span></span><span class="c1">// Return the maximum sum of a row in the 2D array.</span>
<span class="kt">int</span> <span class="nf">max_row_sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="n">TEST_ARRAY_SIZE</span><span class="p">][</span><span class="n">TEST_ARRAY_SIZE</span><span class="p">],</span> <span class="kt">int</span> <span class="n">side_length</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// PUT YOUR CODE HERE (you must change the next line!)</span>
    <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


Add code so that <b>max_row_sum</b> finds the row in the 
square two dimensional array with the highest sum, and returns that value.
You are guaranteed the array will only contain positive numbers.

<p>
For example if the array is a 3 height by 3 width array
</p><p>
</p><pre>6, 7, 8,
1, 1, 9,
3, 2, 8
</pre>
<p>
Your function should return <b>21</b> because:
</p><p>
  </p><pre>6 + 7 + 8 == <b>21</b>
1 + 1 + 9 == 11
3 + 2 + 8 == 13

</pre>
<p>
As you can see, the largest row sum is 21.
</p>

<h4>Testing</h4>

<b>array_2d_max_row_sum.c</b> also contains a simple <b>main</b> function which allows
you to test your <b>max_row_sum</b> function.
<p>

Your <b>max_row_sum</b> function will be called directly in marking.
The main function is only to let you test your <b>max_row_sum</b> function
</p><p>

</p><h4>Assumptions/Restrictions/Clarifications.</h4>

<b>max_row_sum</b> should return a single integer.
<p>
<b>max_row_sum</b> should not change the array it is given.
</p><p>
<b>max_row_sum</b> should not call scanf (or getchar or fgets).
</p><p>
<b>max_row_sum</b> can assume the array contains at least one integer. </p><p> <b>max_row_sum</b> function should not print anything. It should not call printf.
</p><p>
Your submitted file may contain a main function. It will not be tested or marked.









</p><div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style prac_q1.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest exam_array_2d_max_row_sum</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you must

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab10_exam_array_2d_max_row_sum prac_q1.c</kbd>
</pre>

<p>

You must run <code>give</code>

before <strong>Tuesday 24 November 2020 20:00</strong>
to obtain the marks for this lab exercise.


Note that this is an individual exercise,
the work you submit with <code>give</code> must be entirely your own.





    
        
        
            
            </p><div class="answer">
                Sample solution for <code>prac_q1.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#define TEST_ARRAY_SIZE 100</span>

<span class="c1">// Return the result of summing each row in the 2D array,</span>
<span class="c1">// then multiplying them together</span>
<span class="c1">// A "small" value is greater than -10 and less than +10.</span>
<span class="kt">int</span> <span class="nf">max_row_sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="n">TEST_ARRAY_SIZE</span><span class="p">][</span><span class="n">TEST_ARRAY_SIZE</span><span class="p">],</span> <span class="kt">int</span> <span class="n">side_length</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// PUT YOUR CODE HERE (you must change the next line!)</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">row</span> <span class="o">&lt;</span> <span class="n">side_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">row_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">col</span> <span class="o">&lt;</span> <span class="n">side_length</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">row_sum</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">];</span>
            <span class="n">col</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="n">row_sum</span><span class="p">)</span> <span class="n">max</span> <span class="o">=</span> <span class="n">row_sum</span><span class="p">;</span>
        <span class="n">row</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// This is a simple main function which could be used</span>
<span class="c1">// to test your max_row_sum function.</span>
<span class="c1">// It will not be marked.</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">test_array</span><span class="p">[</span><span class="n">TEST_ARRAY_SIZE</span><span class="p">][</span><span class="n">TEST_ARRAY_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span>   <span class="mi">2</span><span class="p">,</span>   <span class="mi">3</span><span class="p">,</span>    <span class="mi">4</span> <span class="p">},</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">11</span><span class="p">,</span>  <span class="mi">11</span><span class="p">,</span>   <span class="mi">1</span>  <span class="p">},</span>
        <span class="p">{</span><span class="mi">1</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>   <span class="mi">1</span><span class="p">,</span>    <span class="mi">1</span> <span class="p">},</span>
        <span class="p">{</span><span class="mi">22</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>   <span class="mi">2</span><span class="p">,</span>    <span class="mi">2</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">max_row_sum</span><span class="p">(</span><span class="n">test_array</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Largest row sum in 1x1 array: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">max_row_sum</span><span class="p">(</span><span class="n">test_array</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Largest row sum in 2x2 array: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">max_row_sum</span><span class="p">(</span><span class="n">test_array</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Largest row sum in 3x3 array: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">max_row_sum</span><span class="p">(</span><span class="n">test_array</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Largest row sum in 4x4 array: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-self">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — individual:
    </small><br>Practice Exam Q2 - Count the number of even numbers in a linked list</h3></header>
    









Note <b>list_count_last.c</b> uses the following familiar data type:

<pre class="program">struct node {
    struct node *next;
    int          data;
};
</pre>


<b>count_last</b> is given one argument, <b>head</b>, which is the pointer to the first node in a linked list.
You are guaranteed the list will not be empty.
<p>
Add code to <b>count_last</b> so that its returns the number of values which are the same as the last value in the list.
</p><p>
For example if the linked list contains these 8 values:
</p><p>
</p><pre>16, 12, 8, 12, 13, 19, 21, 12
</pre>
<p>
  <b>count_last</b> should return <b>3</b>, because 12 is the last value, and 12 occurs 3 times in the list
  (including the last number).
</p><p>

</p><h4>Testing</h4>

<b>list_count_last.c</b> also contains a <b>main</b> function which allows you to test your <b>count_last</b> function.
<p>
This main function:
</p><ul>
<li> converts the command-line arguments to a linked list
</li><li> assigns a pointer to the first node in the linked list to <b>head</b>
</li><li> calls <b>count_last(head)</b>
</li><li> prints the result.
</li></ul>
<p>
</p><p>
Do not change this main function.  If you want to change it, you have misread the question.
</p><p>
Your <b>count_last</b> function will be called directly in marking.  The main function is only to let you test your <b>count_last</b> function
</p><p>
Here is how you use main function allows you to test <b>count_last</b>:
</p><p>

</p><pre is="tty"><kbd is="sh">cp -n /web/cs1511/20T3/activities/exam_list_count_last/list_count_last.c .</kbd>
<kbd is="sh">dcc list_count_last.c -o list_count_last</kbd>
<kbd is="sh">./list_count_last 16 12 8 12 13 19 21 12</kbd>
3
<kbd is="sh">./list_count_last 2 4 6 2 4 6</kbd>
2
<kbd is="sh">./list_count_last 3 5 7 11 13 15 17 19 23 29</kbd>
1
<kbd is="sh">./list_count_last 2 2 2 3 2</kbd>
4
</pre>




<h4>Assumptions/Restrictions/Clarifications.</h4>

<p>
<b>count_last</b> will never receive a linked list with no nodes. That is, the head will never be <code>NULL</code>
</p><p>
<b>count_last</b> should return a single integer.
</p><p>
<b>count_last</b> should not change the linked list it is given.
Your function should not change the next or data fields of list nodes.
</p><p>
<b>count_last</b> should not use arrays.
</p><p>
<b>count_last</b> should not call malloc.
</p><p>
<b>count_last</b> should not call scanf (or getchar or fgets).
</p><p>
<b>count_last</b> should not print anything. It should not call printf.
</p><p>
Do not change the supplied <b>main</b> function. It will not be tested or marked.









</p><div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style prac_q2.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest exam_list_count_last</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you must

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab10_exam_list_count_last prac_q2.c</kbd>
</pre>

<p>

You must run <code>give</code>

before <strong>Tuesday 24 November 2020 20:00</strong>
to obtain the marks for this lab exercise.


Note that this is an individual exercise,
the work you submit with <code>give</code> must be entirely your own.





    
        
        
            
            </p><div class="answer">
                Sample solution for <code>prac_q2.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">count_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>

<span class="c1">// DO NOT CHANGE THIS MAIN FUNCTION</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// create linked list from command line arguments</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">count_last</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="c1">// return the number of values in a linked list equal to the</span>
<span class="c1">// last value in that linked list.</span>
<span class="kt">int</span> <span class="nf">count_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">last_val</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">iter</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">last_val</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">iter</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="n">last_val</span><span class="p">)</span> <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="n">iter</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">count</span><span class="p">;</span>

<span class="p">}</span>


<span class="c1">// DO NOT CHANGE THIS FUNCTION</span>

<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-self">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — individual:
    </small><br>Practice Exam Q4 - Count the number of times the same number is in the same position in a pair of linked lists</h3></header>
    











<p>
Download exam_list_delete_last.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/exam_list_delete_last/exam_list_delete_last.c">here</a>, or copy it to your CSE
account using the following command:

</p><pre is="tty"><kbd is="sh">cp -n /web/cs1511/20T3/activities/exam_list_delete_last/exam_list_delete_last.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>exam_list_delete_last.c</b>:


</p><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Delete the last node in list.</span>
<span class="c1">// The deleted node is freed.</span>
<span class="c1">// The head of the list is returned.</span>
<span class="c1">//</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">delete_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// PUT YOUR CODE HERE (change the next line!)</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>





Note <b>list_delete_last.c</b> uses the following familiar data type:

<pre class="program">struct node {
    struct node *next;
    int          data;
};
</pre>

<b>delete_last</b> is given  one argument, <b>head</b>, which is the pointer to the first node in a linked list.
<p>
Add code to <b>delete_last</b> so that it deletes the last node from list.
</p><p>
<b>delete_last</b> should return a pointer to the new list.
</p><p>
If the list is now empty <b>delete_last</b> should return <b>NULL</b>.
</p><p>
<b>delete_last</b> should call <b>free</b> to free the memory of the node it deletes.
</p><p>
For example if the linked list contains these 8 elements:
</p><p>
</p><pre>16, 7, 8, 12, 13, 19, 21, 12
</pre>
<p>
<b>delete_last</b> should return a pointer to a list with these elements:
</p><p>
</p><pre>16, 7, 8, 12, 13, 19, 21
</pre>

<h4>Testing</h4>

<b>list_delete_last.c</b> also contains a <b>main</b> function which allows you to test your <b>delete_last</b> function.
<p>
This main function:
</p><ul>
<li> converts the command-line arguments to a linked list
</li><li> assigns a pointer to the first node in the linked list to <b>head</b>
</li><li> calls <b>delete_last(head)</b>
</li><li> prints the result.
</li></ul>
<p>
Do not change this main function.  If you want to change it, you have misread the question.
</p><p>
Your <b>delete_last</b> function will be called directly in marking.  The main function is only to let you test your <b>delete_last</b> function
</p><p>

</p><pre is="tty"><kbd is="sh">cp -n /web/cs1511/20T3/activities/exam_list_delete_last/list_delete_last.c .</kbd>
<kbd is="sh">dcc list_delete_last.c -o list_delete_last</kbd>
<kbd is="sh">./list_delete_last 16 7 8 12 13 19 21 12</kbd>
[16, 7, 8, 12, 13, 19, 21]
<kbd is="sh">./list_delete_last 2 4 6 2 4 6</kbd>
[2, 4, 6, 2, 4]
<kbd is="sh">./list_delete_last 42</kbd>
[]
<kbd is="sh">./list_delete_last</kbd>
[]
</pre>




<h4>Assumptions/Restrictions/Clarifications.</h4>

<b>delete_last</b> should call <b>free</b> to free the memory for the node it deletes
<p>
<b>delete_first</b> should not change the data fields of list nodes.
</p><p>
<b>delete_last</b> should not use arrays.
</p><p>
<b>delete_last</b> should not call malloc.
</p><p>
<b>delete_last</b> should not call scanf (or getchar or fgets).
</p><p>
<b>delete_last</b> should not print anything. It should not call printf.
</p><p>
Do not change the supplied <b>main</b> function. It will not be tested or marked.









</p><div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style prac_q4.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest exam_list_delete_last</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you must

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab10_exam_list_delete_last prac_q4.c</kbd>
</pre>

<p>

You must run <code>give</code>

before <strong>Tuesday 24 November 2020 20:00</strong>
to obtain the marks for this lab exercise.


Note that this is an individual exercise,
the work you submit with <code>give</code> must be entirely your own.





    
        
        
            
            </p><div class="answer">
                Sample solution for <code>prac_q4.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">int</span>          <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">delete_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[]);</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="c1">// create linked list from command line arguments</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">strings_to_list</span><span class="p">(</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">new_head</span> <span class="o">=</span> <span class="n">delete_last</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
    <span class="n">print_list</span><span class="p">(</span><span class="n">new_head</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Delete the last node in list.</span>
<span class="c1">// The deleted node is freed.</span>
<span class="c1">// The head of the list is returned.</span>

<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">delete_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// list is empty no node to delete</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// list has one node, head is now NULL</span>
        <span class="n">free</span><span class="p">(</span><span class="n">head</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="c1">// find second last node in list</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// create linked list from array of strings</span>
<span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="nf">strings_to_list</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strings</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">strings</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">head</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// print linked list</span>
<span class="kt">void</span> <span class="nf">print_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"["</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">n</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If you're getting an error here,</span>
        <span class="c1">// you have returned an invalid list</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">", "</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"]</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-pair">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Exercise — in pairs:
    </small><br>Padding (moving all elements) a character list</h3></header>
    











<p>
Download padding_left.c <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/activities/padding_left/padding_left.c">here</a>, or copy it to your CSE
account using the following command:

</p><pre is="tty"><kbd is="sh">cp -n /web/cs1511/20T3/activities/padding_left/padding_left.c .</kbd>
</pre>




<p>
Your task is to add code to this function in <b>padding_left.c</b>:


</p><div class="highlight"><pre><span></span><span class="c1">// Given a list of characters, move each character</span>
<span class="c1">// along one, putting "pad_character" in the first place,</span>
<span class="c1">// and ignoring the last character.</span>
<span class="c1">//</span>
<span class="c1">// Given the list 'c' 'e' 'l' 'l' 'o'; calling left_pad</span>
<span class="c1">// once with pad_character = 'x' results in the list:</span>
<span class="c1">// 'x' 'c' 'e' 'l' 'l'. Calling it again with pad_character = 'e'</span>
<span class="c1">// results in the list: 'e' 'x' 'c' 'e' 'l'</span>
<span class="c1">//</span>
<span class="c1">// Note that you can't malloc, or modify the lists' nodes</span>
<span class="c1">// You can only move data around the list.</span>
<span class="kt">void</span> <span class="nf">pad_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">character_node</span> <span class="o">*</span><span class="n">characters</span><span class="p">,</span> <span class="kt">char</span> <span class="n">pad_character</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// TODO: COMPLETE THIS FUNCTION</span>
<span class="p">}</span>
</pre></div>




<p>
</p><p>
<b>padding_left</b> is written using the following structs that cannot be changed:
</p><p>
</p><pre>// A node in a linked list of characters.
struct character_node {
    char data;
    struct character_node *next;
};
</pre>
<p>
The <b>character_node</b> struct holds a character, as part of a linked list of characters.
</p><p> 
<b>pad_left</b> is given a pointer to a <b>character_node</b>, which is the
first element in a list of characters. It is also given a character to "pad" with.

</p><p>
When you "pad" a character list, you iterate over the list and "push" every character along one.
This means that the second character becomes whatever the first character was. The third becomes
whatever the second was, and so on.
The first character becomes <b>pad_character</b>, and what was previously the last character is
"forgotten".
</p>

<p>
For example if a list of characters called <b>characters</b> looks like this:
</p><p>
</p><pre>abcdef
</pre>
<p>
Then the following function is called:
</p><p>
</p><pre>pad_left(characters, 't');
</pre>
<p>
The list <b>characters</b> would be:
</p><p>
</p><pre>tabcde
</pre>

<div class="alert alert-success"><strong>Hint: </strong>
You will need to use multiple temporary character variables to complete this exercise!</div>

<h4>Examples</h4>

<pre is="tty"><kbd is="sh">dcc padding_left.c -o padding_left</kbd>
<kbd is="sh">./padding_left lights</kbd>
<kbd>a</kbd>
alight
<kbd>m</kbd>
maligh
<kbd>&gt;</kbd>
&gt;malig
<kbd>&gt;</kbd>
&gt;&gt;mali
<span class="eof"></span>
</pre>

<pre is="tty"><kbd is="sh">dcc padding_left.c -o padding_left</kbd>
<kbd is="sh">./padding_left cello</kbd>
<kbd>x</kbd>
xcell
<kbd>e</kbd>
excel
<span class="eof"></span>
</pre>

<h4>Assumptions/Restrictions/Clarifications.</h4>
<p>
<b>struct character_node</b> cannot be edited. It must be
used as is.
</p><p>
The <b>string_to_characters</b>, <b>print_characters</b>, and
<b>free_characters</b> functions will help you test and run your program.
They cannot be edited and must be used as it is. <i>You should not use them 
yourself in <b>pad_left</b></i>
</p><p>
<b>pad_left</b> cannot return a new head, so you cannot add to the head of the list.
You should complete this task solely by moving around data -
you will not need to malloc yourself.
</p><p>
Your submitted file may contain a main function. It will not be tested or marked.









</p><div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style padding_left.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest padding_left</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you and your lab partner must both

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab10_padding_left padding_left.c</kbd>
</pre>

<p>

Note, even though this is a pair exercise,
you both must run <code>give</code> from your own account

before <strong>Tuesday 24 November 2020 20:00</strong>
to obtain the marks for this lab exercise.






    
        
        
            
            </p><div class="answer">
                Sample solution for <code>padding_left.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cp">#define MAX_NAME_LENGTH 100</span>

<span class="c1">// Do not edit these structs. You may use them exactly as</span>
<span class="c1">// they are but you cannot make changes to them</span>

<span class="c1">// A node in a linked list of characters</span>
<span class="k">struct</span> <span class="n">character_node</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">character_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// DECLARE ANY FUNCTIONS YOU WRITE HERE</span>

<span class="c1">// Given a list of characters, move each character</span>
<span class="c1">// along one, putting "pad_character" in the first place,</span>
<span class="c1">// and ignoring the last character.</span>
<span class="c1">//</span>
<span class="c1">// Given the list 'c' 'e' 'l' 'l' 'o'; calling left_pad</span>
<span class="c1">// once with pad_character = 'x' results in the list:</span>
<span class="c1">// 'x' 'c' 'e' 'l' 'l'. Calling it again with pad_character = 'e'</span>
<span class="c1">// results in the list: 'e' 'x' 'c' 'e' 'l'</span>
<span class="c1">//</span>
<span class="c1">// Note that you can't malloc, or modify the lists' nodes</span>
<span class="c1">// You can only move data around the list.</span>
<span class="kt">void</span> <span class="nf">pad_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">character_node</span> <span class="o">*</span><span class="n">characters</span><span class="p">,</span> <span class="kt">char</span> <span class="n">pad_character</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">old</span> <span class="o">=</span> <span class="n">pad_character</span><span class="p">,</span> <span class="n">new</span> <span class="o">=</span> <span class="n">pad_character</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">characters</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">characters</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="n">characters</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">old</span><span class="p">;</span>

        <span class="n">characters</span> <span class="o">=</span> <span class="n">characters</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// These helper functions are only for this main, but</span>
<span class="c1">// may help you to both understand and test this exercise.</span>
<span class="c1">// They will not help you in the above exercise.</span>
<span class="c1">// You may use these functions for testing, but</span>
<span class="c1">// YOU CANNOT CHANGE THESE FUNCTIONS</span>

<span class="c1">// Convert a string to a linked list of nodes, one per character</span>
<span class="k">struct</span> <span class="n">character_node</span> <span class="o">*</span><span class="nf">string_to_characters</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">character_node</span> <span class="o">*</span><span class="n">list_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="kt">int</span> <span class="n">curr_char</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">curr_char</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">character_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">character_node</span><span class="p">));</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">curr_char</span><span class="p">];</span>
        <span class="n">n</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">list_head</span><span class="p">;</span>
        <span class="n">list_head</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="n">curr_char</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">list_head</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_characters</span><span class="p">(</span><span class="k">struct</span> <span class="n">character_node</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">putchar</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">putchar</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_characters</span><span class="p">(</span><span class="k">struct</span> <span class="n">character_node</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free_characters</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">free</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// This is a main function which could be used</span>
<span class="c1">// to test your pad_left function.</span>
<span class="c1">// It will not be marked.</span>
<span class="c1">// Only your pad_left function will be marked.</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Usage: %s a_string_to_pad</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">string</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">struct</span> <span class="n">character_node</span> <span class="o">*</span><span class="n">characters</span> <span class="o">=</span> <span class="n">string_to_characters</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">pad_character</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">pad_character</span> <span class="o">=</span> <span class="n">getchar</span><span class="p">())</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pad_character</span> <span class="o">==</span> <span class="sc">'\n'</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">print_characters</span><span class="p">(</span><span class="n">characters</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">pad_left</span><span class="p">(</span><span class="n">characters</span><span class="p">,</span> <span class="n">pad_character</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
        
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// DEFINE ANY FUNCTIONS YOU WRITE HERE</span>
</pre></div>


                
            </div>
            
        
    



    </section>

 






    


<section class="exercise with-self">
    <header><h3><small style="font-variant: small-caps; text-transform: lowercase;">Challenge Exercise — individual:
    </small><br>Hard Challenge - Knight Moves, Final Question from a previous exam</h3></header>
    









This question was taken from a past exam paper. It is an example of the hardest
question at the end of the paper and it is usually expected that less than 5%
of students can complete this question within the time constraints.
<p>
Write a C program knight_moves.c which prints  sequences of moves which takes a knight from a specified
square on a chessboard to another specified square on the chessboard.
</p><p>
A chessboard is an 8x8 square matrix.  We label each square as below:
</p><p>
</p><pre is="tty">a8 b8 c8 d8 e8 f8 g8 h8
a7 b7 c7 d7 e7 f7 g7 h7
a6 b6 c6 d6 e6 f6 g6 h6
a5 b5 c5 d5 e5 f5 g5 h5
a4 b4 c4 d4 e4 f4 g4 h4
a3 b3 c3 d3 e3 f3 g3 h3
a2 b2 c2 d2 e2 f2 g2 h2
a1 b1 c1 d1 e1 f1 g1 h1
</pre>
<p>
A knight makes an L-shaped move.  It moves either two squares horizontally and one square vertically
or two squares vertically and one square horizontally.
</p><p>
For example, a knight at <i>d4</i> can move to one of eight squares: <i>c2</i>, <i>e2</i>, <i>b3</i>, <i>b5</i>, <i>c6</i>, <i>e6</i>, <i>f3</i> or <i>f5</i>.
</p><p>
A move can not take a knight off the chessboard.  Hence, a knight on square near the edge of
the board will have fewer possible moves.
</p><p>
For example, a knight at <i>a1</i> can move only to <i>c2</i> and <i>b3</i>.
</p><p>
Write a C program which takes  two arguments: a starting square and
and a finishing square.
</p><p>
It should print a sequence of moves which take a knight from
the starting square to the finishing square.
This sequence of moves should be as short as possible.
</p><p>
In many cases there are multiple shortest sequences,
your program must print all of the sequences in alphabetic order
</p><p>
For example:
</p><p>
</p><pre is="tty"><kbd is="sh">dcc -o knight_moves knight_moves.c</kbd>
<kbd is="sh">./knight_moves d4 b3</kbd>
d4 b3 
<kbd is="sh">./knight_moves d4 a1</kbd>
d4 b3 a1
d4 c2 a1
<kbd is="sh">./knight_moves g2 b2</kbd>
g2 e1 d3 b2
g2 e3 c4 b2
g2 e3 d1 b2
g2 f4 d3 b2
</pre>
<p>
<b>Assumptions/Restrictions/Clarifications</b>
</p><p>
</p><p>
Your program must complete in 60 seconds when executed with dcc --valgrind
</p><p>
Your can assume there are two command-line arguments and they correctly identify squares on the board.
</p><p>
You can assume the starting and finishing squares are different.
</p><p>
No error checking required









</p><div class="alert alert-info">
<strong>New!</strong>
You can run an automated code style checker using the following command:

<pre is="tty"><kbd is="sh">1511 style knight_moves.c</kbd>
</pre>
</div>




<p>
When you think your program is working,
you can use <code>autotest</code>
to run some simple automated tests:

</p><pre is="tty"><kbd is="sh">1511 autotest knight_moves</kbd>
</pre>
















<p>
When you are finished working on this exercise,

you must

submit your work by running <code>give</code>:

</p><pre is="tty"><kbd is="sh">give cs1511 lab10_knight_moves knight_moves.c</kbd>
</pre>

<p>

You must run <code>give</code>

before <strong>Tuesday 24 November 2020 20:00</strong>
to obtain the marks for this lab exercise.


Note that this is an individual exercise,
the work you submit with <code>give</code> must be entirely your own.





    
        
        
            
            </p><div class="answer">
                Sample solution for <code>knight_moves.c</code>
                
<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>

<span class="cp">#define BOARD_SIZE 8</span>

<span class="kt">int</span> <span class="n">column_delta</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">row_delta</span><span class="p">[]</span>    <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">1</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">print_moves</span><span class="p">(</span><span class="kt">int</span> <span class="n">max_path_length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">finish_column</span><span class="p">,</span> <span class="kt">int</span> <span class="n">finish_row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">path_length</span><span class="p">,</span> <span class="kt">int</span> <span class="n">path</span><span class="p">[][</span><span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">last_column</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">path_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">last_row</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">path_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">last_column</span> <span class="o">==</span> <span class="n">finish_column</span> <span class="o">&amp;&amp;</span> <span class="n">last_row</span> <span class="o">==</span> <span class="n">finish_row</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">path_length</span> <span class="o">==</span>  <span class="n">max_path_length</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">path_length</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%c%c"</span><span class="p">,</span> <span class="sc">'a'</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="sc">'1'</span><span class="o">+</span><span class="n">path</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">path_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">" "</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">path_length</span> <span class="o">==</span> <span class="n">max_path_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">paths_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">new_column</span> <span class="o">=</span>  <span class="n">last_column</span> <span class="o">+</span> <span class="n">column_delta</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">new_row</span> <span class="o">=</span> <span class="n">last_row</span> <span class="o">+</span> <span class="n">row_delta</span><span class="p">[</span><span class="n">m</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new_column</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">new_column</span> <span class="o">&lt;</span> <span class="n">BOARD_SIZE</span> <span class="o">&amp;&amp;</span> <span class="n">new_row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">new_row</span> <span class="o">&lt;</span> <span class="n">BOARD_SIZE</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">p</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">path_length</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_column</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">new_row</span><span class="p">)</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">path_length</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">path</span><span class="p">[</span><span class="n">path_length</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_column</span><span class="p">;</span>
                <span class="n">path</span><span class="p">[</span><span class="n">path_length</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_row</span><span class="p">;</span>
                <span class="n">paths_found</span> <span class="o">+=</span> <span class="n">print_moves</span><span class="p">(</span><span class="n">max_path_length</span><span class="p">,</span> <span class="n">finish_column</span><span class="p">,</span> <span class="n">finish_row</span><span class="p">,</span> <span class="n">path_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">paths_found</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">start_column</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">start_row</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'1'</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start_column</span> <span class="o">&amp;&amp;</span> <span class="n">start_column</span> <span class="o">&lt;</span> <span class="n">BOARD_SIZE</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">start_row</span> <span class="o">&amp;&amp;</span> <span class="n">start_row</span> <span class="o">&lt;</span> <span class="n">BOARD_SIZE</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">finish_column</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">finish_row</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'1'</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">finish_column</span> <span class="o">&amp;&amp;</span> <span class="n">finish_column</span> <span class="o">&lt;</span> <span class="n">BOARD_SIZE</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">finish_row</span> <span class="o">&amp;&amp;</span> <span class="n">finish_row</span> <span class="o">&lt;</span> <span class="n">BOARD_SIZE</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">path_length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="p">;</span><span class="n">path_length</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">path</span><span class="p">[</span><span class="n">path_length</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
        <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_column</span><span class="p">;</span>
        <span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_row</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">print_moves</span><span class="p">(</span><span class="n">path_length</span><span class="p">,</span> <span class="n">finish_column</span><span class="p">,</span> <span class="n">finish_row</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


                
            </div>
            
        
    



    </section>





<section class="exercise ">
    <header><h3>Submission</h3></header>
    


When you are finished each exercises make sure you submit your work by running <code>give</code>.
<p>
You can run <code>give</code> multiple times.
Only your last submission will be marked.
</p><p>
Don't submit any exercises you haven't attempted.
</p><p>
If you are working at home, you may find it more convenient
to upload your work via
<a href="https://cgi.cse.unsw.edu.au/~give/Student/give.php">give's web interface</a>.
</p><p>
Remember you have until

<b>Week 11 Tuesday 20:00</b>

to submit your work.
</p><p>
You cannot obtain marks by e-mailing your code to tutors or lecturers.
</p><p>
You check the files you have submitted <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">here</a>.
</p><p>
Automarking will be run by the lecturer several days after the submission deadline,
using test cases different to those <code>autotest</code> runs for you.
(Hint: do your own testing as well as running <code>autotest</code>.)
</p><p>
After automarking is run by the lecturer
you can <a href="https://cgi.cse.unsw.edu.au/~cs1511/20T3/student/">view your results here</a>.
The resulting mark will also be available
<a href="https://cgi.cse.unsw.edu.au/~give/Student/sturec.php">via give's web interface</a>.

</p><h4>Lab Marks</h4>
<p>
When all components of a lab  are automarked you should be able to view the
the marks <a href="https://cgi.cse.unsw.edu.au/~give/Student/sturec.php">via give's web interface</a>
or by running this command on a CSE machine:

</p><pre is="tty"><kbd is="sh">1511 classrun -sturec</kbd>
</pre>










    </section>


</div>



</main>

<footer class="mt-3 pt-3 bg-dark text-center no-print">
<p class="text-muted">
<strong>COMP1511 20T3: Programming Fundamentals</strong>
is brought to you by <br>
the <a href="https://www.cse.unsw.edu.au/">School of Computer Science and Engineering</a><br>
at the <a href="https://www.unsw.edu.au/">University of New South Wales</a>, Sydney.<br>
For all enquiries, please email the class account at
<a href="mailto:@cse.unsw.edu.au">cs1511@cse.unsw.edu.au</a><br>

<small>CRICOS Provider 00098G</small>
</p>


</footer>


</body></html>